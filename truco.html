<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Truco Paulista</title>
  <style>
    /* Estilos gerais */
    body {
      background: linear-gradient(135deg, #0a5c0a, #157f15);
      color: white;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      text-align: center;
      margin: 0;
      overflow: hidden; /* Previne barras de rolagem */
      background-color: green;
    }

    /* --- ESTILOS DO MENU E REGRAS --- */
    #menu-inicio, #regras-jogo {
        position: fixed; /* Cobre a tela toda */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #0a5c0a, #157f15);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100; /* Fica na frente da mesa */
        padding: 20px;
        box-sizing: border-box;
        text-align: center;
        color: white;
        background-color: green;
    }

    #menu-inicio h1 {
        font-size: 3rem;
        margin-bottom: 40px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }

    #menu-inicio button, #regras-jogo button {
        padding: 15px 30px;
        font-size: 1.4rem;
        font-weight: bold;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.1s;
        box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        margin: 10px;
        min-width: 150px;
    }

     #menu-inicio button:hover, #regras-jogo button:hover {
        transform: translateY(-3px);
     }
     #menu-inicio button:active, #regras-jogo button:active {
        transform: scale(0.98);
     }

    #botao-jogar-menu {
      background-color: #28a745; color: white;
    }
     #botao-jogar-menu:hover { background-color: #218838; }

    #botao-regras-menu {
      background-color: #007bff; color: white;
    }
     #botao-regras-menu:hover { background-color: #0056b3; }

    #regras-jogo {
        justify-content: flex-start; /* Alinha conteúdo no topo */
        overflow-y: auto; /* Permite rolar se as regras forem longas */
        text-align: left; /* Melhora leitura das regras */
        display: none; /* Começa escondido */
    }

    #regras-jogo h2 {
        text-align: center;
        margin-bottom: 20px;
         text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
    }

    #regras-jogo .regras-content {
        background-color: rgba(0, 0, 0, 0.3);
        padding: 15px 25px;
        border-radius: 8px;
        max-width: 600px;
        width: 90%;
        margin-bottom: 20px;
    }

    #regras-jogo p, #regras-jogo li {
      line-height: 1.6;
      margin-bottom: 10px;
    }
    #regras-jogo ul {
      padding-left: 20px;
      margin-bottom: 15px;
    }
     #regras-jogo strong {
       color: #ffc107; /* Amarelo para destaque */
     }


    #botao-voltar-menu {
       background-color: #dc3545; color: white;
       margin-top: 15px; /* Espaço acima do botão voltar */
       align-self: center; /* Centraliza o botão voltar */
    }
     #botao-voltar-menu:hover { background-color: #c82333; }

    /* --- ESTILOS DO JOGO (Mesa) --- */
    #mesa {
      /* display: flex; */ /* Removido daqui, será controlado pelo JS */
      display: none; /* << IMPORTANTE: Mesa começa escondida */
      flex-direction: column;
      height: 100vh;
      justify-content: space-between;
      padding: 10px;
      position: relative; /* Necessário para posicionar elementos filhos */
      box-sizing: border-box; /* Inclui padding na altura */
    }

    .mao {
      display: flex;
      justify-content: center;
      gap: 10px;
      padding: 15px;
      min-height: 100px;
      align-items: center; /* Alinha itens verticalmente */
    }

    .carta {
      background: white;
      color: black;
      border: 1px solid black;
      padding: 35px 15px;
      border-radius: 8px;
      font-size: 1.3rem;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      transition: transform 0.2s, box-shadow 0.2s;
      display: inline-block;
      min-width: 50px;
      text-align: center;
      user-select: none; /* Impede seleção de texto */
    }

    .carta.escondida { /* Estilo para carta virada da máquina */
      background: linear-gradient(135deg, #444, #888);
      color: transparent;
      border-color: #222;
       cursor: default; /* Não clicável */
    }


    .carta:hover:not(.escondida) { /* Aplica hover apenas se não estiver escondida */
      transform: translateY(-6px); /* Efeito hover sutil */
      box-shadow: 0 4px 8px rgba(0,0,0,0.4);
    }

    #centro {
      display: flex;
      justify-content: space-around; /* Distribui espaço */
      align-items: center;
      gap: 15px;
      margin: 10px 0;
      min-height: 150px; /* Altura mínima aumentada */
      flex-grow: 1; /* Permite que o centro ocupe espaço */
      padding: 0 20px; /* Adiciona padding lateral */
    }

   #jogada-maquina, #jogada-jogador {
      min-width: 70px; /* Largura mínima */
      min-height: 100px; /* Altura mínima */
      display: flex;
      justify-content: center;
      align-items: center;
      border: 1px dashed rgba(255, 255, 255, 0.2); /* Placeholder visual */
      border-radius: 8px;
    }

    #info-centro {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        min-width: 100px;
    }

     #valor-mao-atual {
        font-size: 1.1rem;
        font-weight: bold;
        background-color: rgba(0,0,0,0.5);
        padding: 4px 8px;
        border-radius: 5px;
        margin-bottom: 5px;
    }

     #carta-virada-display {
         min-height: 90px;
         display: flex;
         align-items: center;
         justify-content: center;
     }

     #manilha-info {
         font-size: 1.1rem;
         font-weight: bold;
         background-color: rgba(0,0,0,0.4);
         padding: 3px 6px;
         border-radius: 4px;
     }


    #rodadas {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 6px;
    }

    .bolinha {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid white;
      background: transparent;
      transition: background 0.3s;
    }

    .empate { background: orange; }
    .vencedor-jogador { background: blue; }
    .vencedor-maquina { background: red; }

    #placar-final {
      position: absolute;
      bottom: 480px; /* Ajustado */
      left: 90px;
      font-size: 1.0rem;
      background-color: rgba(0, 0, 0, 0.6);
      padding: 5px 8px;
      border-radius: 6px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.5);
      z-index: 10;
    }

    /* Controles de Truco */
    #truco-controles {
      position: absolute;
      bottom: 130px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      background-color: rgba(0, 0, 0, 0.4);
      padding: 12px;
      border-radius: 10px;
      z-index: 20;
      min-width: 280px;
      text-align: center;
    }

    #truco-controles button {
      padding: 8px 16px;
      font-size: 1.0rem;
      font-weight: bold;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.4);
    }

    #truco-controles button:active:not(:disabled) {
        transform: scale(0.98);
    }

    /* Botão principal de pedir aposta */
    #botao-truco {
      background-color: #ffc107; color: #333;
      min-width: 80px; /* Largura mínima para caber texto */
    }
    #botao-truco:hover:not(:disabled) { background-color: #e0a800; }
    #botao-truco:disabled { background-color: #ccc; color: #888; cursor: not-allowed; opacity: 0.6; }

    /* Container dos botões de resposta */
    #resposta-truco {
       display: flex;
       gap: 5px;
       flex-wrap: wrap;
       justify-content: center;
       min-height: 35px; /* Evita pular layout */
    }
    #resposta-truco button { margin: 0; }

    /* Botões de Resposta específicos */
    #botao-aceitar-truco { background-color: #28a745; color: white; }
    #botao-aceitar-truco:hover { background-color: #218838; }
    #botao-recusar-truco { background-color: #dc3545; color: white; }
    #botao-recusar-truco:hover { background-color: #c82333; }
    #botao-aumentar-aposta { background-color: #007bff; color: white; }
    #botao-aumentar-aposta:hover { background-color: #0056b3; }

     /* Botão Jogar Novamente */
     #botao-jogar-novamente { background-color: #17a2b8; color: white; margin-top: 10px; }
     #botao-jogar-novamente:hover { background-color: #138496; }

    /* Mensagem */
    #mensagem-truco {
      font-size: 1.1rem;
      font-weight: bold;
      min-height: 18px;
      margin-bottom: 5px;
      color: #ffc107; /* Cor amarela para destaque */
      text-shadow: 1px 1px 2px black;
    }

  </style>
</head>
<body>

  <div id="menu-inicio">
    <h1>Truco Paulista</h1>
    <button id="botao-jogar-menu">Jogar</button>
    <button id="botao-regras-menu">Regras</button>
  </div>

  <div id="regras-jogo">
    <h2>Regras do Truco Paulista</h2>
    <div class="regras-content">
      <p><strong>Objetivo:</strong> Ser a primeira dupla (ou jogador, neste caso contra a máquina) a alcançar 12 pontos.</p>
      <p><strong>Baralho:</strong> Utiliza-se um baralho espanhol limpo (sem 8, 9, 10 e coringas) ou um baralho francês adaptado, removendo essas cartas.</p>
      <p><strong>Cartas e Força (Manilhas):</strong></p>
      <ul>
        <li>A cada mão, uma carta é virada ("vira"). A carta seguinte na sequência de valores define as <strong>manilhas</strong> (as cartas mais fortes daquela mão).</li>
        <li>Ordem de força das manilhas (da mais forte para a mais fraca): <strong>Paus (Zap) ♣️ > Copas ♥️ > Espadas ♠️ > Ouros ♦️</strong>.</li>
        <li>Se a vira for um 3, as manilhas serão os 4s, seguindo a ordem de naipes acima.</li>
      </ul>
       <p><strong>Cartas Comuns (Força Normal - da mais forte para a mais fraca):</strong></p>
       <ul>
         <li><strong>3 > 2 > A (Ás) > K (Rei) > J (Valete) > Q (Dama) > 7 > 6 > 5 > 4</strong></li>
         <li>Cartas de mesmo valor têm a mesma força (ex: um 7♦️ empata com um 7♠️, se não forem manilhas).</li>
       </ul>
      <p><strong>Como Jogar:</strong></p>
      <ul>
        <li>Cada jogador recebe 3 cartas.</li>
        <li>A mão é disputada em melhor de 3 rodadas. Quem ganhar 2 rodadas vence a mão.</li>
        <li>Em cada rodada, cada jogador joga uma carta. A carta de maior força vence a rodada.</li>
        <li>Se a primeira rodada empatar, quem ganhar a segunda vence a mão.</li>
        <li>Se a segunda rodada empatar, quem ganhou a primeira vence a mão.</li>
        <li>Se a primeira e a segunda rodadas empatarem, quem ganhar a terceira vence a mão.</li>
        <li>Se as três rodadas empatarem ("cangar"), ninguém marca pontos na mão.</li>
        <li>Quem vence a rodada começa jogando na próxima.</li>
        <li> **Modificado:** Quem vence a *mão* começa jogando a *próxima mão*. Se empatar, o jogador humano começa.</li>
      </ul>
      <p><strong>Pontuação e Truco:</strong></p>
      <ul>
        <li>Uma mão normal vale <strong>1 ponto</strong>.</li>
        <li>Um jogador pode pedir <strong>"Truco!"</strong> a qualquer momento antes de jogar sua carta na sua vez. Isso aumenta o valor da mão para <strong>3 pontos</strong>.</li>
        <li>O adversário pode:
            <ul>
                <li><strong>Aceitar:</strong> A mão passa a valer 3 pontos.</li>
                <li><strong>Recusar ("Correr"):</strong> Quem pediu truco ganha 1 ponto.</li>
                <li><strong>Pedir "Seis!" (ou "Meio-Pau"):</strong> Aumenta a aposta para 6 pontos.</li>
            </ul>
        </li>
        <li>Se "Seis" for pedido, o jogador que pediu "Truco" pode aceitar (mão vale 6), recusar (adversário ganha 3 pontos) ou pedir <strong>"Nove!"</strong>.</li>
        <li>Se "Nove" for pedido, o outro jogador pode aceitar (mão vale 9) ou recusar (adversário ganha 6 pontos).</li>
         <li>Se "Doze" for pedido (geralmente quando já se tem 9 pontos), o outro jogador pode aceitar (mão vale 12 - e o jogo acaba se o placar permitir) ou recusar (adversário ganha 9 pontos).</li>
        <li>**Mão de Onze:** Quando uma dupla (ou jogador) atinge 11 pontos, a próxima mão vale 3 pontos automaticamente. Os jogadores olham as cartas e decidem se jogam (aceitam) ou correm (dão 1 ponto ao adversário). Nesta mão especial, não é permitido pedir truco. (Esta regra específica da Mão de Onze não está implementada neste código, a aposta pode ser aumentada normalmente).</li>
      </ul>
    </div>
    <button id="botao-voltar-menu">Voltar</button>
  </div>

  <div id="mesa">
    <div class="mao" id="mao-maquina"></div>

    <div id="centro">
      <div id="jogada-maquina"></div>
      <div id="info-centro">
          <div id="valor-mao-atual">Vale: 1 ponto</div>
          <div id="carta-virada-display"></div>
          <div id="manilha-info">Manilha: ?</div>
      </div>
      <div id="jogada-jogador"></div>
    </div>

    <div class="mao" id="mao-jogador"></div>

    <div id="rodadas">
      <div class="bolinha" id="bolinha-rodada1"></div>
      <div class="bolinha" id="bolinha-rodada2"></div>
      <div class="bolinha" id="bolinha-rodada3"></div>
    </div>
    <div id="placar-final">Placar: Você 0 x 0 Máquina</div>

    <div id="truco-controles">
        <div id="mensagem-truco"></div>
        <button id="botao-truco" onclick="pedirApostaJogador()" disabled>Truco!</button>
        <div id="resposta-truco"></div>
        <div id="fim-jogo-controles" style="display: none;">
            <button id="botao-jogar-novamente" onclick="jogarNovamente()">Jogar Novamente</button>
        </div>
    </div>
  </div>

<script>
    // --- Constantes Globais ---
    const NAIPES = ['♦️', '♠️', '♥️', '♣️'];
    const VALORES = [4, 5, 6, 7, 'Q', 'J', 'K', 'A', 2, 3];
    const VALOR_MAP = { 4: 4, 5: 5, 6: 6, 7: 7, 'Q': 10, 'J': 11, 'K': 12, 'A': 13, 2: 14, 3: 15 };
    const PONTOS_VITORIA = 12;

    // --- Níveis de Aposta e Pontuações ---
    const NIVEIS_APOSTA = {
        NORMAL: { valor: 1, proximo: 'TRUCO', nomeDisplay: 'Mão',    recusaPaga: 1 },
        TRUCO:  { valor: 3, proximo: 'SEIS',  nomeDisplay: 'Truco',  recusaPaga: 1 },
        SEIS:   { valor: 6, proximo: 'NOVE',  nomeDisplay: 'Seis',   recusaPaga: 3 },
        NOVE:   { valor: 9, proximo: 'DOZE',  nomeDisplay: 'Nove',   recusaPaga: 6 },
        DOZE:   { valor: 12, proximo: null,   nomeDisplay: 'Doze',   recusaPaga: 9 }
    };

    // --- Variáveis Globais de Estado ---
    let baralho = [];
    let maoJogador = [], maoMaquina = [];
    let manilhaValor, vira;
    let rodadaAtual = 1, vitoriasRodadaJogador = 0, vitoriasRodadaMaquina = 0, empatesRodada = 0;
    let jogadorDaVez = 'jogador', quemIniciouRodada = 'jogador';
    let cartaJogadaCentroJogador = null, cartaJogadaCentroMaquina = null;
    let pontuacaoJogador = 0, pontuacaoMaquina = 0;
    let podeJogar = false, jogoEmAndamento = false; // <<< Jogo começa parado

    let vencedorDaMaoAnterior = 'jogador'; // <<< VARIÁVEL ADICIONADA: Guarda quem ganhou a última mão (jogador ou maquina)

    // --- Variáveis de Estado do Truco ---
    let nivelApostaAtual = 'NORMAL';
    let pontosDaMaoAtual = NIVEIS_APOSTA.NORMAL.valor;
    let estadoTruco = 'normal';
    let quemPediuUltimaAposta = null;

    // --- Elementos da UI (cache) ---
    // <<< Elementos do Menu/Regras >>>
    let menuInicio, regrasJogo, botaoJogarMenu, botaoRegrasMenu, botaoVoltarMenu, mesaJogo;
    // <<< Elementos do Jogo (já existentes) >>>
    let elMaoJogador, elMaoMaquina, elJogadaJogador, elJogadaMaquina, elCartaVirada, elManilhaInfo, elPlacarFinal, elValorMaoAtual, elBotaoTruco, elMensagemTruco, elRespostaTruco, elFimJogoControles;

    // --- Funções Auxiliares ---
    function formatarValorDisplay(valor) { return String(valor); }
    function criarElementoCarta(carta, escondida = false) {
        const div = document.createElement('div');
        div.className = 'carta';
        if (escondida) { div.classList.add('escondida'); }
        else if (carta && carta.valor && carta.naipe) {
            div.textContent = `${formatarValorDisplay(carta.valor)}${carta.naipe}`;
            div.dataset.valor = carta.valor; div.dataset.naipe = carta.naipe;
        } else { div.textContent = '?'; }
        return div;
    }
    function atualizarValorMaoDisplay() {
        if (elValorMaoAtual) {
            elValorMaoAtual.textContent = `Vale: ${pontosDaMaoAtual} ponto${pontosDaMaoAtual > 1 ? 's' : ''}`;
        }
    }

    // --- Lógica Principal (Baralho, Cartas, Força) ---
    function criarBaralho() {
        baralho = [];
        for (let valor of VALORES) {
            for (let naipe of NAIPES) {
            baralho.push({ valor: valor, naipe: naipe, forca: VALOR_MAP[valor] });
            }
        }
    }
    function embaralhar() {
        for (let i = baralho.length - 1; i > 0; i--) {
            let j = Math.floor(Math.random() * (i + 1));
            [baralho[i], baralho[j]] = [baralho[j], baralho[i]];
        }
    }
    function sortearManilha() {
        if (baralho.length <= 7) {
            console.warn("Poucas cartas, recriando baralho...");
            criarBaralho();
            embaralhar();
        }
        vira = baralho.pop();
        const indiceVira = VALORES.indexOf(vira.valor);
        manilhaValor = VALORES[(indiceVira + 1) % VALORES.length];

        if (elCartaVirada) {
            elCartaVirada.innerHTML = '';
            const viraDisplay = criarElementoCarta(vira);
            viraDisplay.style.cursor = 'default';
            viraDisplay.style.boxShadow = '0 0 5px 2px yellow';
            elCartaVirada.appendChild(viraDisplay);
        }
        if (elManilhaInfo) {
            elManilhaInfo.textContent = `Manilha: ${formatarValorDisplay(manilhaValor)}`;
        }
        console.log(`Vira: ${formatarValorDisplay(vira.valor)}${vira.naipe}, Manilha: ${formatarValorDisplay(manilhaValor)}`);
    }
    function distribuirCartas() {
        if (baralho.length < 6) {
            console.error("Erro crítico: Sem cartas suficientes para distribuir!");
            // Idealmente, o jogo deveria parar aqui ou ter um tratamento melhor
            return;
        }
        maoJogador = baralho.splice(0, 3);
        maoMaquina = baralho.splice(0, 3);
        renderizarMaos();
    }
    function renderizarMaos() {
        if (!elMaoJogador || !elMaoMaquina) return;
        elMaoJogador.innerHTML = '';
        maoJogador.forEach((carta, i) => {
            const div = criarElementoCarta(carta);
            div.onclick = () => { if (podeJogar && jogadorDaVez === 'jogador') jogadorJogaCarta(i); };
            elMaoJogador.appendChild(div);
        });
        renderizarMaoMaquinaReal();
    }
     function renderizarMaoMaquinaReal() {
        if (!elMaoMaquina) return;
        elMaoMaquina.innerHTML = '';
        maoMaquina.forEach(() => {
            elMaoMaquina.appendChild(criarElementoCarta({}, true)); // Cria cartas escondidas
        });
    }
     function calcularForca(carta) {
        if (!carta || !carta.valor) return -1; // Carta inválida ou nula
        const valorBase = carta.forca; // Usa o mapeamento VALOR_MAP

        // Checa se é manilha
        if (carta.valor === manilhaValor) {
            // Força das manilhas baseada no naipe
            switch (carta.naipe) {
                case '♣️': return 1000; // Zap (Paus)
                case '♥️': return 999;  // Copas
                case '♠️': return 998;  // Espadas
                case '♦️': return 997;  // Ouros (7 Ouros)
                default: return 100; // Segurança, não deve acontecer
            }
        }
        // Se não for manilha, retorna a força normal da carta
        return valorBase;
    }
    // Função interna para comparar duas cartas
    function compararCartasInterno(c1, c2) {
        if (!c1 && !c2) return 'empate'; // Ambas nulas
        if (!c1) return 'c2'; // Só c2 existe
        if (!c2) return 'c1'; // Só c1 existe

        const f1 = calcularForca(c1);
        const f2 = calcularForca(c2);

        if (f1 === f2) return 'empate';
        return f1 > f2 ? 'c1' : 'c2'; // Retorna qual carta ganhou ('c1' ou 'c2')
    }

    // --- Controle de Botões e Mensagens ---
    function atualizarBotoesTruco() {
        if (!elBotaoTruco || !elRespostaTruco || !elFimJogoControles) return;

        // Mostra/Esconde botão "Jogar Novamente"
        elFimJogoControles.style.display = (estadoTruco === 'finalizado') ? 'block' : 'none';

        if (estadoTruco === 'finalizado') {
            // Se o jogo acabou, esconde o botão de truco e as respostas
            elBotaoTruco.style.display = 'none';
            elRespostaTruco.innerHTML = '';
            // Mantém a mensagem de fim de jogo
            if (elMensagemTruco && !elMensagemTruco.textContent.startsWith("FIM DE JOGO")) {
                 elMensagemTruco.textContent = '';
            }
        } else {
            // Se o jogo está rolando
            elBotaoTruco.style.display = 'block'; // Mostra botão principal

            const infoNivelAtual = NIVEIS_APOSTA[nivelApostaAtual];
            const proximoNivelChave = infoNivelAtual.proximo;
            let podePedir = false; // Determina se o jogador pode pedir/aumentar a aposta

            if (proximoNivelChave) {
                // Se ainda há níveis de aposta
                const infoProximoNivel = NIVEIS_APOSTA[proximoNivelChave];
                elBotaoTruco.textContent = `${infoProximoNivel.nomeDisplay}!`; // Texto do botão (Truco!, Seis!, etc.)

                // Condições para poder pedir:
                podePedir = jogoEmAndamento &&                     // Jogo tem que estar rolando
                            jogadorDaVez === 'jogador' &&         // Tem que ser a vez do jogador
                            (estadoTruco === 'normal' ||          // Ou o estado é normal (ninguém pediu ainda)
                             (estadoTruco.startsWith('aceito_') && quemPediuUltimaAposta === 'maquina')); // Ou a máquina pediu e o jogador aceitou (jogador pode aumentar)
            } else {
                // Se já está no nível máximo (DOZE)
                elBotaoTruco.textContent = 'Máximo!';
                podePedir = false; // Não pode pedir mais
            }

            // Não pode pedir se já houver um pedido pendente de resposta
            if (estadoTruco.startsWith('pedido_')) {
                podePedir = false;
            }
            // Garante que botão truco esteja desabilitado se o jogo não começou ou acabou
            if (!jogoEmAndamento) podePedir = false;

            elBotaoTruco.disabled = !podePedir; // Habilita/desabilita o botão
        }
    }

    // Mostra uma mensagem na área de truco
    function mostrarMensagemTruco(msg, tempo = 3000) {
        if (!elMensagemTruco) return;
        // Se for a mensagem de fim de jogo, não a apaga com timeout
        if (estadoTruco === 'finalizado' && msg.startsWith("FIM DE JOGO")) {
            elMensagemTruco.textContent = msg;
            return;
        }
        elMensagemTruco.textContent = msg;
        if (tempo > 0) {
            // Limpa a mensagem após 'tempo' ms, a menos que seja uma pergunta esperando resposta
            setTimeout(() => {
                const esperandoRespostaJogador = estadoTruco.startsWith('pedido_') && estadoTruco.endsWith('_maquina');
                if (elMensagemTruco && elMensagemTruco.textContent === msg && !esperandoRespostaJogador && estadoTruco !== 'finalizado') {
                    elMensagemTruco.textContent = '';
                }
            }, tempo);
        }
    }

    // --- Lógica de Jogada de Carta ---
    function jogadorJogaCarta(indice) {
        // Verifica se o jogador PODE jogar
        if (!jogoEmAndamento || !podeJogar || jogadorDaVez !== 'jogador' || estadoTruco.startsWith('pedido_')) {
             if (estadoTruco.startsWith('pedido_')) {
                mostrarMensagemTruco("Responda à aposta antes de jogar!", 2000);
             }
             console.warn("Jogador tentou jogar carta inválida/fora de hora. Estado:", estadoTruco, "Pode jogar:", podeJogar, "Vez:", jogadorDaVez);
            return;
        }
        if (indice < 0 || indice >= maoJogador.length) {
            console.error("Índice de carta inválido:", indice);
            return;
        }

        podeJogar = false; // Impede jogada dupla rápida
        cartaJogadaCentroJogador = maoJogador.splice(indice, 1)[0]; // Remove a carta da mão
        renderizarMaos(); // Atualiza a mão do jogador na tela
        console.log(`Jogador jogou: ${formatarValorDisplay(cartaJogadaCentroJogador.valor)}${cartaJogadaCentroJogador.naipe}`);

        // Mostra a carta jogada no centro
        if (elJogadaJogador) {
            elJogadaJogador.innerHTML = '';
            elJogadaJogador.appendChild(criarElementoCarta(cartaJogadaCentroJogador));
        }

        jogadorDaVez = 'maquina'; // Passa a vez para a máquina
        atualizarBotoesTruco(); // Atualiza botão de truco (desabilita para jogador)

        // Se a máquina ainda não jogou nesta troca, ela decide o que fazer (jogar ou apostar)
        // Se a máquina já jogou, finaliza a rodada
        if (!cartaJogadaCentroMaquina) {
            quemIniciouRodada = 'jogador'; // Jogador iniciou esta troca de cartas na rodada
            setTimeout(maquinaDecideJogada, 800); // Dá um tempo para a IA "pensar"
        } else {
            finalizarRodada(); // Ambas as cartas estão na mesa, compara e finaliza
        }
    }

    function maquinaJogaCarta() {
        // Verifica se a máquina PODE jogar
        if (!jogoEmAndamento || maoMaquina.length === 0 || jogadorDaVez !== 'maquina' || (estadoTruco.startsWith('pedido_') && estadoTruco.endsWith('_maquina'))) {
             if (estadoTruco.startsWith('pedido_') && estadoTruco.endsWith('_maquina')){
                 console.log("Máquina esperando resposta do jogador para a aposta.");
             } else {
                 console.warn(`Máquina impedida de jogar carta. Estado: ${estadoTruco}, Vez: ${jogadorDaVez}, Jogo: ${jogoEmAndamento}, Cartas: ${maoMaquina.length}`);
             }
             return;
         }

        podeJogar = false; // Impede ações enquanto a máquina joga

        let indiceEscolhido = 0;
        // --- Lógica simples da IA para escolher a carta ---
        if (maoMaquina.length > 0) {
            if (cartaJogadaCentroJogador) { // Máquina está respondendo à carta do jogador
                let indiceGanhadora = -1, forcaGanhadoraMaisFraca = 1001; // Guarda a ganhadora mais fraca possível
                let indicePerdedoraMaisFraca = 0, forcaPerdedoraMaisFraca = -1; // Guarda a perdedora mais fraca

                // Acha a perdedora mais fraca (default)
                 if(maoMaquina.length > 0) {
                    forcaPerdedoraMaisFraca = calcularForca(maoMaquina[0]);
                    for(let i = 1; i < maoMaquina.length; i++) {
                         const forcaAtual = calcularForca(maoMaquina[i]);
                         if (forcaAtual < forcaPerdedoraMaisFraca) {
                              indicePerdedoraMaisFraca = i;
                              forcaPerdedoraMaisFraca = forcaAtual;
                          }
                     }
                     // Garante índice válido se só tiver 1 carta, mesmo que não entre no loop
                     if (maoMaquina.length === 1) indicePerdedoraMaisFraca = 0;
                 }

                // Tenta achar a carta mais fraca que GANHA da carta do jogador
                for(let i = 0; i < maoMaquina.length; i++) {
                   const forcaAtual = calcularForca(maoMaquina[i]);
                   // Se a carta da máquina ganha da carta do jogador
                   if (compararCartasInterno(maoMaquina[i], cartaJogadaCentroJogador) === 'c1') {
                       // E é a primeira ganhadora encontrada OU é mais fraca que a ganhadora anterior
                       if (indiceGanhadora === -1 || forcaAtual < forcaGanhadoraMaisFraca) {
                           indiceGanhadora = i; // Guarda esta como a melhor opção (ganhadora mais fraca)
                           forcaGanhadoraMaisFraca = forcaAtual;
                       }
                   }
                }
               // Se achou uma carta que ganha, usa a mais fraca delas. Senão, joga a carta mais fraca que tem.
               indiceEscolhido = (indiceGanhadora !== -1) ? indiceGanhadora : indicePerdedoraMaisFraca;

            } else { // Máquina está iniciando a troca de cartas (jogador ainda não jogou)
                 // Joga a carta mais forte que tiver para tentar garantir a rodada
                 let indiceMaisForte = 0, forcaMaisForte = -1;
                 for(let i = 0; i < maoMaquina.length; i++) {
                     let forcaAtual = calcularForca(maoMaquina[i]);
                     if(forcaAtual > forcaMaisForte) {
                         forcaMaisForte = forcaAtual;
                         indiceMaisForte = i;
                     }
                 }
                 indiceEscolhido = indiceMaisForte;
            }
        } else {
             console.warn("Máquina sem cartas para jogar.");
             // Se máquina não tem carta (não deveria acontecer com a lógica atual, mas por segurança)
              jogadorDaVez = 'jogador';
              podeJogar = true;
              atualizarBotoesTruco();
              finalizarRodada(); // Verifica se a rodada/mão acabou
              return;
        }

        // Garante que o índice é válido (segurança extra)
        if (indiceEscolhido < 0 || indiceEscolhido >= maoMaquina.length) indiceEscolhido = 0;

        cartaJogadaCentroMaquina = maoMaquina.splice(indiceEscolhido, 1)[0]; // Remove carta da mão
        renderizarMaoMaquinaReal(); // Atualiza a mão da máquina (com cartas escondidas)

        // Mostra a carta jogada no centro
        if (elJogadaMaquina) {
            elJogadaMaquina.innerHTML = '';
            elJogadaMaquina.appendChild(criarElementoCarta(cartaJogadaCentroMaquina));
        }
        console.log(`Máquina jogou: ${formatarValorDisplay(cartaJogadaCentroMaquina.valor)}${cartaJogadaCentroMaquina.naipe}`);

        jogadorDaVez = 'jogador'; // Passa a vez para o jogador

        // Se o jogador ainda não jogou, permite que ele jogue. Senão, finaliza a rodada.
        if (!cartaJogadaCentroJogador) {
            quemIniciouRodada = 'maquina'; // Máquina iniciou esta troca
            if (jogoEmAndamento) { // Só permite jogar se o jogo ainda estiver ativo
                podeJogar = true; // Permite ao jogador jogar
                atualizarBotoesTruco(); // Habilita botão de truco para jogador (se aplicável)
            }
        } else {
            finalizarRodada(); // Ambas as cartas estão na mesa
        }
    }

    // --- Lógica de Decisão da Máquina (Aposta ou Joga) ---
    function maquinaDecideJogada() {
        if (!jogoEmAndamento || jogadorDaVez !== 'maquina') return;

        // 1. Se há um pedido do jogador pendente, a máquina deve responder primeiro
        if (estadoTruco.startsWith('pedido_') && estadoTruco.endsWith('_jogador')) {
             console.log("[IA Decisão] Aposta do jogador pendente. Respondendo...");
             // Adiciona um delay aleatório para parecer mais humano
             setTimeout(maquinaRespondeAposta, 700 + Math.random() * 600);
             return; // Não joga carta agora, espera a resposta da aposta
        }

        // 2. Avalia se PODE e DEVE pedir/aumentar aposta
        const infoNivelAtualParaDecisao = NIVEIS_APOSTA[nivelApostaAtual];
        // Pode pedir se: há próximo nível de aposta E (estado normal OU jogador aceitou aposta da máquina)
        const podePedirAgora = infoNivelAtualParaDecisao.proximo &&
                               (estadoTruco === 'normal' || (estadoTruco.startsWith('aceito_') && quemPediuUltimaAposta === 'jogador'));

        // Se pode pedir E a avaliação da mão sugere pedir (função maquinaAvaliaPedirAposta)
        if (podePedirAgora && maquinaAvaliaPedirAposta()) {
            console.log("[IA Decisão] Máquina vai pedir/aumentar aposta.");
            const nivelCorretoParaPedir = infoNivelAtualParaDecisao.proximo; // Pega o próximo nível (TRUCO, SEIS, etc.)

            if (nivelCorretoParaPedir) {
                 // Delay antes de pedir
                setTimeout(() => pedirApostaMaquina(nivelCorretoParaPedir), 500 + Math.random() * 500);
            } else {
                // Segurança: Se algo der errado e não houver próximo nível
                console.warn("IA tentou pedir aposta, mas não há próximo nível a partir de", nivelApostaAtual);
                maquinaJogaCarta(); // Joga carta como fallback
            }
        }
        else {
             // 3. Se não vai apostar, joga uma carta
             maquinaJogaCarta();
        }
    }

    // --- Lógica de Aposta (Pedir, Avaliar, Responder) ---
    function pedirApostaJogador() {
        const infoNivelAtual = NIVEIS_APOSTA[nivelApostaAtual];
        const proximoNivelChave = infoNivelAtual.proximo;
        // Não pode pedir se já está no máximo (DOZE)
        if (!proximoNivelChave) {
            mostrarMensagemTruco("Aposta já está no máximo!", 2000);
            return;
        }

        // Verifica se o jogador PODE pedir (mesma lógica de atualizarBotoesTruco)
        const podePedir = jogoEmAndamento && jogadorDaVez === 'jogador' &&
                          (estadoTruco === 'normal' || (estadoTruco.startsWith('aceito_') && quemPediuUltimaAposta === 'maquina'));

        // Não pode pedir se já tem uma aposta na mesa esperando resposta
        if (estadoTruco.startsWith('pedido_')) {
             mostrarMensagemTruco("Aguarde a resposta ou responda primeiro!", 2500);
             return;
        }

        if (!podePedir) {
            console.warn("Jogador não pode pedir aposta agora. Estado:", estadoTruco, "Vez:", jogadorDaVez, "Último Pedido:", quemPediuUltimaAposta);
            mostrarMensagemTruco("Não é sua vez de pedir/aumentar!", 2000);
            return;
        }

        const infoProximoNivel = NIVEIS_APOSTA[proximoNivelChave];
        console.log(`Jogador pediu ${infoProximoNivel.nomeDisplay}!`);
        estadoTruco = `pedido_${proximoNivelChave.toLowerCase()}_jogador`; // Ex: pedido_truco_jogador
        quemPediuUltimaAposta = 'jogador'; // Marca quem fez o último pedido
        podeJogar = false; // Não pode jogar carta enquanto espera resposta
        atualizarBotoesTruco(); // Desabilita botão de pedir do jogador
        mostrarMensagemTruco(`Você pediu ${infoProximoNivel.nomeDisplay}! Aguardando máquina...`, 0); // Mensagem persistente

        // Delay para a máquina responder
        setTimeout(maquinaRespondeAposta, 1400 + Math.random() * 800);
    }

    function pedirApostaMaquina(nivelParaPedirChave) {
        // Validação básica
        if (!nivelParaPedirChave || !NIVEIS_APOSTA[nivelParaPedirChave]) {
            console.error(`IA: Tentativa de pedir nível inválido ou não fornecido: ${nivelParaPedirChave}`);
            // Tenta jogar carta como fallback se for a vez da máquina
            if (jogadorDaVez === 'maquina') { maquinaJogaCarta(); }
            return;
        }

        const infoNivelPedido = NIVEIS_APOSTA[nivelParaPedirChave];
        console.log(`Máquina pediu ${infoNivelPedido.nomeDisplay}!`);

        estadoTruco = `pedido_${nivelParaPedirChave.toLowerCase()}_maquina`; // Ex: pedido_seis_maquina
        quemPediuUltimaAposta = 'maquina';
        podeJogar = false; // Jogador não pode jogar carta

        mostrarMensagemTruco(`Máquina pediu ${infoNivelPedido.nomeDisplay}! Responda:`, 0); // Mensagem persistente

        // Cria os botões de resposta para o jogador
        if (elRespostaTruco) {
            elRespostaTruco.innerHTML = ''; // Limpa botões antigos
            // Botão Aceitar
            elRespostaTruco.innerHTML += `<button id="botao-aceitar-truco" onclick="jogadorRespondeAposta('aceitar')">Aceitar (Vale ${infoNivelPedido.valor})</button>`;

            // Botão Recusar
            const pontosRecusa = infoNivelPedido.recusaPaga; // Pontos que a máquina ganha se o jogador recusar
            elRespostaTruco.innerHTML += `<button id="botao-recusar-truco" onclick="jogadorRespondeAposta('recusar')">Recusar (Máq ganha ${pontosRecusa})</button>`;

            // Botão Aumentar (só aparece se não for DOZE)
            if (infoNivelPedido.proximo) {
                const proximoAumentoInfo = NIVEIS_APOSTA[infoNivelPedido.proximo];
                elRespostaTruco.innerHTML += `<button id="botao-aumentar-aposta" onclick="jogadorRespondeAposta('aumentar')">Aumentar (${proximoAumentoInfo.nomeDisplay}!)?</button>`;
            }
        }
        atualizarBotoesTruco(); // Desabilita o botão principal de pedir do jogador
    }

    // IA avalia se deve pedir/aumentar a aposta baseado na mão
    function maquinaAvaliaPedirAposta() {
         if(maoMaquina.length === 0) return false; // Não pede sem cartas

         // Heurística simples:
         const temManilha = maoMaquina.some(carta => calcularForca(carta) >= 997); // Tem alguma das 4 manilhas?
         const fortes = maoMaquina.filter(carta => calcularForca(carta) >= VALOR_MAP['A']).length; // Quantas cartas são Ás, 2 ou 3?
         const nivelAtualChave = nivelApostaAtual; // Nível atual da aposta (NORMAL, TRUCO, etc.)

         // Lógica de decisão simples baseada no nível e nas cartas
         switch(nivelAtualChave) {
             case 'NORMAL': // Para pedir TRUCO
                 // Pede se tiver manilha OU 2+ cartas fortes OU (1 carta forte E está ganhando rodadas)
                 return temManilha || fortes >= 2 || (fortes >= 1 && vitoriasRodadaMaquina > vitoriasRodadaJogador) ;
             case 'TRUCO': // Para pedir SEIS
                 // Pede se tiver manilha E pelo menos 1 carta forte
                 return temManilha && fortes >= 1;
             case 'SEIS': // Para pedir NOVE
                 // Pede se tiver manilha E pelo menos 2 cartas fortes
                  return temManilha && fortes >= 2;
             case 'NOVE': // Para pedir DOZE
                 // Pede se tiver o Zap (Paus) E outra manilha E pelo menos 1 carta forte (incluindo as manilhas)
                 const temZap = maoMaquina.some(c => calcularForca(c) === 1000);
                 return temZap && temManilha && fortes >=1 ; // Se tem zap, já conta como manilha e forte
             default: return false; // Não pede DOZE ou além
         }
    }

    // IA responde a um pedido de aposta do JOGADOR
    function maquinaRespondeAposta() {
         // Verifica se está no estado correto
         if (!estadoTruco.startsWith('pedido_') || !estadoTruco.endsWith('_jogador')) {
             console.error("IA: Função maquinaRespondeAposta chamada em estado inválido:", estadoTruco);
             // Tenta jogar carta como fallback se for a vez da máquina
             if(jogadorDaVez === 'maquina') maquinaJogaCarta();
             return;
         }

         // Extrai o nível que foi pedido (TRUCO, SEIS, etc.)
         const nivelPedidoChave = estadoTruco.split('_')[1].toUpperCase();
         const nivelPedidoInfo = NIVEIS_APOSTA[nivelPedidoChave];
         const pontosGanhosPelaRecusa = nivelPedidoInfo.recusaPaga; // Pontos que o jogador ganha se a máquina recusar

         // Se a máquina não tem mais cartas, ela recusa
         if(maoMaquina.length === 0) {
             console.log("[IA Resp Aposta] Sem cartas, máquina recusa.");
             mostrarMensagemTruco(`Máquina Recusou (sem cartas)! Você ganhou ${pontosGanhosPelaRecusa} ponto${pontosGanhosPelaRecusa > 1 ? 's' : ''}.`, 4000);
             pontuacaoJogador += pontosGanhosPelaRecusa;
             mostrarPlacar();
             finalizarMaoAposRecusa(); // Finaliza a mão
             return;
         }

         // Avalia a mão (similar a maquinaAvaliaPedirAposta)
         const temManilha = maoMaquina.some(carta => calcularForca(carta) >= 997);
         const fortes = maoMaquina.filter(carta => calcularForca(carta) >= VALOR_MAP['A']).length;
         let decisao = 'recusar'; // Decisão padrão

         // Lógica de decisão para responder
         switch(nivelPedidoChave) {
             case 'TRUCO': // Jogador pediu TRUCO
                 // Aceita se tiver manilha OU 1+ forte OU (1 forte E está ganhando)
                 if (temManilha || fortes >= 1 || (fortes >= 1 && vitoriasRodadaMaquina > vitoriasRodadaJogador) ) decisao = 'aceitar';
                 // Se decidiu aceitar E pode aumentar E a avaliação sugere aumentar, decide aumentar
                 if (decisao === 'aceitar' && nivelPedidoInfo.proximo && maquinaAvaliaPedirAposta()) { decisao = 'aumentar'; }
                 break;
             case 'SEIS': // Jogador pediu SEIS
                 // Aceita se tiver manilha E 1+ forte
                 if (temManilha && fortes >= 1) decisao = 'aceitar';
                 if (decisao === 'aceitar' && nivelPedidoInfo.proximo && maquinaAvaliaPedirAposta()) { decisao = 'aumentar'; }
                 break;
             case 'NOVE': // Jogador pediu NOVE
                 // Aceita se tiver manilha E 2+ fortes
                  if (temManilha && fortes >= 2) decisao = 'aceitar';
                  // Avalia se aumenta para DOZE (mesma lógica de pedir DOZE)
                  if (decisao === 'aceitar' && nivelPedidoInfo.proximo && maquinaAvaliaPedirAposta()) { decisao = 'aumentar'; }
                 break;
             case 'DOZE': // Jogador pediu DOZE
                 // Aceita só se tiver Zap E outra manilha
                  const temZap = maoMaquina.some(c => calcularForca(c) === 1000);
                  if (temManilha && temZap) decisao = 'aceitar';
                 break;
         }

         console.log(`[IA Resp Aposta] Jogador pediu: ${nivelPedidoChave}. Mão(M:${temManilha}, F:${fortes}). Decisão: ${decisao}`);

         // Executa a decisão
         if (decisao === 'aceitar') {
             console.log(`Máquina ACEITOU o ${nivelPedidoInfo.nomeDisplay}!`);
             estadoTruco = `aceito_${nivelPedidoChave.toLowerCase()}`; // Ex: aceito_truco
             nivelApostaAtual = nivelPedidoChave; // Atualiza o nível da aposta
             pontosDaMaoAtual = nivelPedidoInfo.valor; // Atualiza os pontos da mão
             quemPediuUltimaAposta = 'jogador'; // Jogador foi o último a propor a aposta aceita
             atualizarValorMaoDisplay();
             mostrarMensagemTruco(`Máquina Aceitou! Mão vale ${pontosDaMaoAtual}. Sua vez de jogar.`, 3000);
             jogadorDaVez = 'jogador'; // Volta a vez para o jogador continuar a rodada
             podeJogar = true;
             atualizarBotoesTruco(); // Habilita o botão de aumentar do jogador (se aplicável)

         } else if (decisao === 'aumentar') {
              const proximoNivelAumento = nivelPedidoInfo.proximo; // Pega o próximo nível (SEIS, NOVE, DOZE)
              // Segurança: Verifica se realmente existe um próximo nível
              if (!proximoNivelAumento) {
                    console.error("IA tentou aumentar além do DOZE!");
                    // Fallback: Aceita o nível atual como segurança
                     console.log(`Máquina ACEITOU o ${nivelPedidoInfo.nomeDisplay}! (Fallback)`);
                     estadoTruco = `aceito_${nivelPedidoChave.toLowerCase()}`;
                     nivelApostaAtual = nivelPedidoChave;
                     pontosDaMaoAtual = nivelPedidoInfo.valor;
                     quemPediuUltimaAposta = 'jogador';
                     atualizarValorMaoDisplay();
                     mostrarMensagemTruco(`Máquina Aceitou! Mão vale ${pontosDaMaoAtual}. Sua vez de jogar.`, 3000);
                     jogadorDaVez = 'jogador';
                     podeJogar = true;
                     atualizarBotoesTruco();
                    return;
              }
              console.log(`Máquina decidiu AUMENTAR para ${NIVEIS_APOSTA[proximoNivelAumento].nomeDisplay}!`);
              // Chama a função para a máquina fazer o pedido de aumento
              pedirApostaMaquina(proximoNivelAumento);

         } else { // decisao === 'recusar'
             console.log(`Máquina RECUSOU o ${nivelPedidoInfo.nomeDisplay}!`);
             mostrarMensagemTruco(`Máquina Recusou! Você ganhou ${pontosGanhosPelaRecusa} ponto${pontosGanhosPelaRecusa > 1 ? 's' : ''}.`, 4000);
             pontuacaoJogador += pontosGanhosPelaRecusa; // Adiciona pontos ao jogador
             mostrarPlacar();
             finalizarMaoAposRecusa(); // Encerra a mão
         }
    }

    // Jogador responde a um pedido de aposta da MÁQUINA (clicando nos botões)
    function jogadorRespondeAposta(resposta) {
         // Verifica se está no estado correto
         if (!estadoTruco.startsWith('pedido_') || !estadoTruco.endsWith('_maquina')) {
             console.error("Jogador tentou responder aposta em estado inválido:", estadoTruco);
             mostrarMensagemTruco("Não há aposta da máquina para responder.", 2000);
             return;
         }

         // Extrai o nível que foi pedido pela máquina
         const nivelPedidoChave = estadoTruco.split('_')[1].toUpperCase();
         const nivelPedidoInfo = NIVEIS_APOSTA[nivelPedidoChave];
         const pontosGanhosPelaRecusa = nivelPedidoInfo.recusaPaga; // Pontos que a máquina ganha se o jogador recusar

         // Limpa os botões de resposta
         if (elRespostaTruco) elRespostaTruco.innerHTML = '';

         if (resposta === 'aceitar') {
             console.log(`Jogador ACEITOU o ${nivelPedidoInfo.nomeDisplay}!`);
             estadoTruco = `aceito_${nivelPedidoChave.toLowerCase()}`; // Ex: aceito_seis
             nivelApostaAtual = nivelPedidoChave; // Atualiza nível da aposta
             pontosDaMaoAtual = nivelPedidoInfo.valor; // Atualiza pontos da mão
             quemPediuUltimaAposta = 'maquina'; // Máquina foi a última a propor a aposta aceita
             atualizarValorMaoDisplay();
             mostrarMensagemTruco(`Você Aceitou! Mão vale ${pontosDaMaoAtual}. Máquina continua...`, 3000);
             jogadorDaVez = 'maquina'; // A vez continua/volta para a máquina jogar a carta
             podeJogar = false; // Jogador não pode jogar agora
             atualizarBotoesTruco(); // Atualiza botões (habilita o de aumentar da máquina, se aplicável)
             // Delay antes da máquina jogar a carta
             setTimeout(maquinaDecideJogada, 800);

         } else if (resposta === 'aumentar') {
             const proximoNivelChave = nivelPedidoInfo.proximo; // Pega o próximo nível (SEIS, NOVE, DOZE)
             // Segurança: Verifica se realmente pode aumentar
             if (!proximoNivelChave) {
                 console.error("Erro: Jogador tentou aumentar além do Doze!");
                 // Reapresenta a questão para o jogador escolher aceitar/recusar o DOZE
                 pedirApostaMaquina(nivelPedidoChave); // Chama de novo para mostrar os botões de DOZE
                 return;
             }
             console.log(`Jogador decidiu AUMENTAR para ${NIVEIS_APOSTA[proximoNivelChave].nomeDisplay}!`);
             const infoProximoNivel = NIVEIS_APOSTA[proximoNivelChave];
             // Agora o estado é um pedido do JOGADOR para o próximo nível
             estadoTruco = `pedido_${proximoNivelChave.toLowerCase()}_jogador`; // Ex: pedido_nove_jogador
             quemPediuUltimaAposta = 'jogador';
             podeJogar = false;
             mostrarMensagemTruco(`Você pediu ${infoProximoNivel.nomeDisplay}! Aguardando máquina...`, 0); // Mensagem persistente
             atualizarBotoesTruco(); // Desabilita botão principal do jogador
             // Delay para a máquina responder ao aumento do jogador
             setTimeout(maquinaRespondeAposta, 1400 + Math.random() * 800);

         } else { // resposta === 'recusar'
             console.log(`Jogador RECUSOU o ${nivelPedidoInfo.nomeDisplay}!`);
             mostrarMensagemTruco(`Você Recusou! Máquina ganhou ${pontosGanhosPelaRecusa} ponto${pontosGanhosPelaRecusa > 1 ? 's' : ''}.`, 4000);
             pontuacaoMaquina += pontosGanhosPelaRecusa; // Adiciona pontos à máquina
             mostrarPlacar();
             finalizarMaoAposRecusa(); // Encerra a mão
         }
    }

    // --- Finalização da Mão e Jogo ---

    // Função chamada especificamente quando uma aposta é recusada
    function finalizarMaoAposRecusa() {
         console.log("Finalizando mão após recusa de aposta.");
         nivelApostaAtual = 'NORMAL'; // Reseta nível para próxima mão
         estadoTruco = 'normal';    // Reseta estado do truco
         mostrarPlacar();
         podeJogar = false;
         revelarCartasMaquinaFimJogo(); // Mostra cartas da máquina

         // Verifica se a pontuação atingiu a vitória
         if (pontuacaoJogador >= PONTOS_VITORIA || pontuacaoMaquina >= PONTOS_VITORIA) {
             jogoEmAndamento = false;
             estadoTruco = 'finalizado'; // Marca o jogo como finalizado
             let msgFinal = `FIM DE JOGO! ${pontuacaoJogador >= PONTOS_VITORIA ? 'Você venceu' : 'A Máquina venceu'} (por recusa de aposta)!`;
             console.log(msgFinal);
             mostrarMensagemTruco(msgFinal, 0); // Mostra mensagem final persistente
             atualizarBotoesTruco(); // Mostra o botão "Jogar Novamente"
             vencedorDaMaoAnterior = (pontuacaoJogador >= PONTOS_VITORIA) ? 'jogador' : 'maquina'; // Guarda quem ganhou o jogo
         } else {
             // Se o jogo não acabou, prepara a próxima mão
             console.log("Preparando próxima mão após recusa...");
             // Guarda quem ganhou os pontos pela recusa para iniciar a próxima mão
             // (A pontuação já foi adicionada, então verificamos quem está na frente ou quem pediu)
              vencedorDaMaoAnterior = quemPediuUltimaAposta === 'jogador' ? 'jogador' : 'maquina';

             setTimeout(() => {
                  if (estadoTruco !== 'finalizado') { // Checa novamente se o jogo não acabou
                     iniciarPartida(); // Inicia a próxima mão
                 }
             }, 3500); // Tempo maior para ler a mensagem de recusa
         }
    }

    // Finaliza uma rodada (comparando as cartas jogadas)
    function finalizarRodada() {
        // Não faz nada se o jogo/mão já acabou
        if (!jogoEmAndamento || estadoTruco === 'finalizado') {
            console.log("Tentativa de finalizar rodada com jogo/mão já finalizado.");
            return;
        }
        // Loga o estado se for suspeito (aposta pendente)
         if (estadoTruco.startsWith('pedido_')) {
              console.warn("Finalizando rodada com aposta pendente? Estado:", estadoTruco);
         }

        const cJogador = cartaJogadaCentroJogador;
        const cMaquina = cartaJogadaCentroMaquina;

        // Precisa ter as duas cartas no centro para comparar
        if (!cJogador || !cMaquina) {
            console.log("Rodada não pode ser finalizada: falta carta de um dos jogadores no centro.");
            // Isso pode acontecer se a lógica de turno falhar, mas não deveria.
            // Se acontecer, pode ser necessário forçar o próximo turno ou resetar.
             if (jogadorDaVez === 'jogador') podeJogar = true; // Devolve a vez se algo deu errado
            return;
        }

        // Compara as cartas
        const resultado = compararCartasInterno(cJogador, cMaquina);
        const bolinha = document.getElementById(`bolinha-rodada${rodadaAtual}`);
        if(!bolinha) { console.error("Elemento bolinha não encontrado para rodada:", rodadaAtual); }

        // Define quem começa jogando a PRÓXIMA rodada (não a próxima mão)
        let proximoJogadorIniciaRodada = quemIniciouRodada; // Quem começa a próxima rodada é quem ganhou esta

         console.log(`Resultado Rodada ${rodadaAtual}: Jogador(${cJogador ? formatarValorDisplay(cJogador.valor)+cJogador.naipe : 'X'}) vs Máquina(${cMaquina ? formatarValorDisplay(cMaquina.valor)+cMaquina.naipe : 'X'}) -> ${resultado}`);

        // Atualiza contagem de vitórias e cor da bolinha
        if (resultado === 'c1') { // Jogador ganhou a rodada
            vitoriasRodadaJogador++;
             if(bolinha) bolinha.className = 'bolinha vencedor-jogador';
            proximoJogadorIniciaRodada = 'jogador';
        } else if (resultado === 'c2') { // Máquina ganhou a rodada
            vitoriasRodadaMaquina++;
             if(bolinha) bolinha.className = 'bolinha vencedor-maquina';
            proximoJogadorIniciaRodada = 'maquina';
        } else { // Empate na rodada
            empatesRodada++;
            if(bolinha) bolinha.className = 'bolinha empate';
            // Se empatou, quem começou a rodada anterior começa a próxima (regra comum)
            // Se for a primeira rodada, quem ganhou a mão anterior (ou jogador por padrão) começa.
            // A variável `quemIniciouRodada` já guarda quem começou esta troca, então se empatar, ele começa de novo.
            proximoJogadorIniciaRodada = quemIniciouRodada; // Quem começou esta, começa a próxima se empatar
            console.log(`Rodada ${rodadaAtual} empatou. Próximo a iniciar rodada: ${proximoJogadorIniciaRodada}`);
        }

        // Define quem joga a primeira carta da próxima rodada
        jogadorDaVez = proximoJogadorIniciaRodada;
        quemIniciouRodada = proximoJogadorIniciaRodada; // Atualiza quem vai iniciar a próxima troca
        rodadaAtual++; // Avança para a próxima rodada

        // Delay para limpar a mesa e verificar fim da mão/jogo
        setTimeout(() => {
            // Limpa as cartas do centro
            if(elJogadaJogador) elJogadaJogador.innerHTML = '';
            if(elJogadaMaquina) elJogadaMaquina.innerHTML = '';
            cartaJogadaCentroJogador = null;
            cartaJogadaCentroMaquina = null;

            // Verifica se a MÃO acabou (e consequentemente o jogo)
            if(jogoEmAndamento && estadoTruco !== 'finalizado') {
                 if (!verificarFimPartida()) { // Se a mão NÃO acabou
                      iniciarTurno(); // Começa a próxima rodada/turno
                 }
             } else {
                  console.log("FinalizarRodada: Jogo/Mão já encerrado, não iniciando novo turno.");
                  // Atualiza botões caso o jogo tenha sido finalizado neste ponto
                  if(estadoTruco === 'finalizado') atualizarBotoesTruco();
             }
        }, 1800); // Tempo para ver o resultado da rodada
    }

    // Verifica se a MÃO atual terminou e atualiza o placar/inicia próxima mão ou jogo
    function verificarFimPartida() {
        // Não verifica se o jogo já está finalizado ou esperando resposta de aposta
        if (!jogoEmAndamento || estadoTruco.startsWith('pedido_') || estadoTruco === 'finalizado') return false;

        let fimDeMao = false;
        let vencedorMao = null; // 'jogador', 'maquina' ou null (empate)
        let motivo = ""; // Para log
        let pontosGanhosNaMao = pontosDaMaoAtual; // Pontos em disputa nesta mão

        // --- Condições de Fim de Mão ---
        // 1. Alguém fez 2 vitórias de rodada
        if (vitoriasRodadaJogador >= 2) { fimDeMao = true; vencedorMao = 'jogador'; motivo = "Jogador fez 2 vitórias."; }
        else if (vitoriasRodadaMaquina >= 2) { fimDeMao = true; vencedorMao = 'maquina'; motivo = "Máquina fez 2 vitórias."; }
        // 2. Empatou a primeira e alguém ganhou a segunda (mão acaba na segunda rodada)
        else if (rodadaAtual > 2 && empatesRodada >= 1 && document.getElementById('bolinha-rodada1')?.classList.contains('empate')) {
             const b2 = document.getElementById('bolinha-rodada2')?.classList;
             if (b2?.contains('vencedor-jogador')) { fimDeMao = true; vencedorMao = 'jogador'; motivo = "Empatou 1a, Jogador ganhou 2a."; }
             else if (b2?.contains('vencedor-maquina')) { fimDeMao = true; vencedorMao = 'maquina'; motivo = "Empatou 1a, Máquina ganhou 2a."; }
             // Se empatou a primeira E a segunda, continua para a terceira
        }
        // 3. Ganhou a primeira e empatou a segunda (mão acaba na segunda rodada)
         else if (rodadaAtual > 2 && empatesRodada >= 1 && document.getElementById('bolinha-rodada2')?.classList.contains('empate') ) {
             const b1 = document.getElementById('bolinha-rodada1')?.classList;
              if (b1?.contains('vencedor-jogador')) { fimDeMao = true; vencedorMao = 'jogador'; motivo = "Jogador ganhou 1a, Empatou 2a."; }
              else if (b1?.contains('vencedor-maquina')) { fimDeMao = true; vencedorMao = 'maquina'; motivo = "Máquina ganhou 1a, Empatou 2a."; }
        }
        // 4. Chegou na terceira rodada (rodadaAtual > 3 significa que a 3ª acabou de ser processada)
        else if (rodadaAtual > 3) {
            fimDeMao = true;
            motivo = "3 rodadas completas. ";
            // 4a. Empate triplo ou Empate 1a e 2a (quem ganha a 3a leva) ou Empate 1a e 3a (quem ganhou a 2a leva) etc.
            // Simplificação: Verifica vitórias totais após 3 rodadas.
            if (vitoriasRodadaJogador > vitoriasRodadaMaquina) { vencedorMao = 'jogador'; motivo += "Jogador com mais vitórias."; }
            else if (vitoriasRodadaMaquina > vitoriasRodadaJogador) { vencedorMao = 'maquina'; motivo += "Máquina com mais vitórias."; }
            else { // Empate em número de vitórias (1x1 com 1 empate, ou 0x0 com 3 empates)
                // Regra do Truco: Quem ganhou a primeira rodada vence em caso de empate em vitórias após 3 rodadas.
                const b1 = document.getElementById('bolinha-rodada1')?.classList;
                if (empatesRodada === 3 || // Empate triplo ("Cangar")
                   (b1?.contains('empate') && document.getElementById('bolinha-rodada2')?.classList.contains('empate')) ) // Empatou as duas primeiras, resultado da 3a define
                {
                    const b3 = document.getElementById('bolinha-rodada3')?.classList;
                     if (b3?.contains('vencedor-jogador')) { vencedorMao = 'jogador'; motivo += "Empatou 1a e 2a, Jogador ganhou 3a.";}
                     else if (b3?.contains('vencedor-maquina')) {vencedorMao = 'maquina'; motivo += "Empatou 1a e 2a, Máquina ganhou 3a.";}
                     else { // Empate triplo
                         vencedorMao = null; motivo += "Empate triplo (cangou)."; pontosGanhosNaMao = 0;
                     }

                } else if (b1?.contains('vencedor-jogador')) { // Jogador ganhou a primeira (desempate)
                     vencedorMao = 'jogador';
                     motivo += `Desempate pela 1a rodada (jogador).`;
                } else if (b1?.contains('vencedor-maquina')) { // Máquina ganhou a primeira (desempate)
                      vencedorMao = 'maquina';
                      motivo += `Desempate pela 1a rodada (máquina).`;
                } else { // Caso não previsto (ex: erro nas classes das bolinhas)
                     console.warn("Condição de desempate final inesperada:", {vJ:vitoriasRodadaJogador, vM:vitoriasRodadaMaquina, E:empatesRodada});
                     vencedorMao = null; motivo += "Empate complexo."; pontosGanhosNaMao = 0;
                }
            }
        }

        // --- Processamento do Fim da Mão ---
        if (fimDeMao) {
            console.log(`---------------- Fim da Mão (${motivo}) ----------------`);
            podeJogar = false; // Ninguém pode jogar mais nesta mão
            estadoTruco = 'normal'; // Reseta estado do truco para a próxima mão
            revelarCartasMaquinaFimJogo(); // Mostra as cartas restantes da máquina

            vencedorDaMaoAnterior = vencedorMao; // <<< ATUALIZA QUEM GANHOU ESTA MÃO

            // Adiciona pontos e mostra mensagem
            if (vencedorMao === 'jogador') {
                pontuacaoJogador += pontosGanhosNaMao;
                mostrarMensagemTruco(`Você ganhou a mão! (+${pontosGanhosNaMao})`, 3000);
            } else if (vencedorMao === 'maquina') {
                pontuacaoMaquina += pontosGanhosNaMao;
                 mostrarMensagemTruco(`Máquina ganhou a mão! (+${pontosGanhosNaMao})`, 3000);
            } else { // Empate (Cangou)
                vencedorDaMaoAnterior = 'jogador'; // <<< SE EMPATOU, JOGADOR COMEÇA A PRÓXIMA
                console.log("Mão empatada sem pontuação.");
                mostrarMensagemTruco("Mão empatou! Ninguém pontua.", 3000);
            }
            mostrarPlacar(); // Atualiza o placar na tela

            // --- Verificação de Fim de JOGO ---
             if (pontuacaoJogador >= PONTOS_VITORIA || pontuacaoMaquina >= PONTOS_VITORIA) {
                 jogoEmAndamento = false; // Jogo acabou
                 estadoTruco = 'finalizado'; // Marca como finalizado
                 let msgFinal = `FIM DE JOGO! ${pontuacaoJogador >= PONTOS_VITORIA ? 'Você venceu!' : 'A Máquina venceu!'}`;
                 console.log(msgFinal);
                 // Pequeno delay para garantir que a mensagem de ganhar a mão apareça antes da de fim de jogo
                 setTimeout(() => mostrarMensagemTruco(msgFinal, 0), 50);
                 atualizarBotoesTruco(); // Mostra botão "Jogar Novamente"
                 // Não agenda a próxima mão
             } else {
                 // --- Prepara a Próxima Mão ---
                 console.log(`Preparando próxima mão... Vencedor anterior foi: ${vencedorDaMaoAnterior}`);
                 setTimeout(() => {
                     if (estadoTruco !== 'finalizado') { // Checa de novo (segurança)
                         iniciarPartida(); // Chama a função para começar a próxima mão
                     }
                 }, 3000); // Tempo para ler a mensagem da mão
             }
             return true; // Indica que a mão terminou
        }

        return false; // Mão não terminou ainda
    }

    // --- Controle de Turno e Placar ---

    // Inicia um turno (vez de jogar carta ou decidir aposta)
    function iniciarTurno() {
        // Não inicia turno se o jogo acabou ou está esperando resposta de aposta
        if (!jogoEmAndamento || estadoTruco === 'finalizado') {
            console.log("Início de turno bloqueado: jogo finalizado.");
            atualizarBotoesTruco(); // Garante que botões estejam no estado final
            return;
        }
        if (estadoTruco.startsWith('pedido_')) {
            console.log("Início de turno bloqueado: aposta pendente.");
             atualizarBotoesTruco(); // Garante botões corretos para responder aposta
            return;
        }

        // Limpa as cartas do centro (caso não tenha sido limpo por finalizarRodada)
        if(elJogadaJogador) elJogadaJogador.innerHTML = '';
        if(elJogadaMaquina) elJogadaMaquina.innerHTML = '';
        cartaJogadaCentroJogador = null;
        cartaJogadaCentroMaquina = null;

         console.log(`--- Rodada ${rodadaAtual}, Vez de ${jogadorDaVez}, Mão valendo ${pontosDaMaoAtual} ---`);

        // Se for a vez da máquina
        if (jogadorDaVez === 'maquina') {
            podeJogar = false; // Jogador não pode clicar
            atualizarBotoesTruco(); // Desabilita botão de truco do jogador
            // Delay para a máquina "pensar"
            setTimeout(maquinaDecideJogada, 900 + Math.random() * 400);
        } else { // Se for a vez do jogador
            podeJogar = true; // Jogador pode clicar nas cartas
            atualizarBotoesTruco(); // Habilita botão de truco do jogador (se aplicável)
             console.log("Aguardando jogador...");
        }
    }
    // Atualiza o placar na tela
    function mostrarPlacar() {
        if(elPlacarFinal){
             elPlacarFinal.innerText = `Placar: Você ${pontuacaoJogador} x ${pontuacaoMaquina} Máquina`;
        } else { console.error("Elemento 'placar-final' não encontrado!") }
    }

    // --- Função para iniciar nova MÃO ---
    function iniciarPartida() { // Renomeado para iniciarMao seria mais preciso, mas mantendo o original
      // Não inicia nova mão se o jogo já terminou (esperando clicar em jogar novamente)
      if (!jogoEmAndamento && estadoTruco === 'finalizado') {
            console.log("Jogo finalizado. Não iniciando nova partida automaticamente (esperando 'Jogar Novamente').");
            return;
      }

      console.log("================ Início da Mão ================");
      jogoEmAndamento = true; // Garante que o jogo está ativo para esta mão
      if(elFimJogoControles) elFimJogoControles.style.display = 'none'; // Esconde "Jogar Novamente"
      if(elBotaoTruco) elBotaoTruco.style.display = 'block'; // Mostra botão de truco

      // Prepara o baralho e cartas
      criarBaralho();
      embaralhar();
      sortearManilha();
      distribuirCartas();

      // Reseta contadores e estados da mão
      rodadaAtual = 1;
      vitoriasRodadaJogador = 0; vitoriasRodadaMaquina = 0; empatesRodada = 0;
      // jogadorDaVez = 'jogador'; // <<< REMOVIDO
      // quemIniciouRodada = 'jogador'; // <<< REMOVIDO
      cartaJogadaCentroJogador = null; cartaJogadaCentroMaquina = null;

       // <<< LÓGICA MODIFICADA: DECIDE QUEM COMEÇA A MÃO BASEADO NO VENCEDOR DA MÃO ANTERIOR >>>
        if (vencedorDaMaoAnterior === 'maquina') {
            console.log("Máquina venceu a mão anterior, ela começa esta mão.");
            jogadorDaVez = 'maquina';
            quemIniciouRodada = 'maquina';
        } else {
            // Se jogador ganhou, empatou, ou é a primeira mão do jogo
            console.log("Jogador começa esta mão (venceu/empatou anterior ou é a primeira).");
            jogadorDaVez = 'jogador';
            quemIniciouRodada = 'jogador';
        }
       // <<< FIM DA LÓGICA MODIFICADA >>>

      // Reseta estado e valor da aposta
      nivelApostaAtual = 'NORMAL';
      pontosDaMaoAtual = NIVEIS_APOSTA.NORMAL.valor;
      estadoTruco = 'normal'; // Estado inicial da aposta
      quemPediuUltimaAposta = null;
      atualizarValorMaoDisplay(); // Mostra "Vale: 1 ponto"
      mostrarMensagemTruco('', 0); // Limpa mensagens
      if(elRespostaTruco) elRespostaTruco.innerHTML = ''; // Limpa botões de resposta

      // Limpa as bolinhas de rodada
      for (let i = 1; i <= 3; i++) {
          const bolinha = document.getElementById(`bolinha-rodada${i}`);
          if(bolinha) bolinha.className = 'bolinha';
      }

      // Limpa cartas do centro (redundante, mas seguro)
      if(elJogadaJogador) elJogadaJogador.innerHTML = '';
      if(elJogadaMaquina) elJogadaMaquina.innerHTML = '';

      mostrarPlacar(); // Garante que o placar está visível
      iniciarTurno(); // Começa o primeiro turno da mão com o jogadorDaVez correto
    }

    // --- Função Jogar Novamente ---
    function jogarNovamente() {
        console.log("==================== NOVO JOGO ====================");
        pontuacaoJogador = 0; // Reseta placar
        pontuacaoMaquina = 0;
        estadoTruco = 'normal'; // Reseta estado do truco
        vencedorDaMaoAnterior = 'jogador'; // Garante que jogador comece o novo jogo
        // jogoEmAndamento = true; // Não precisa, iniciarPartida fará isso
        iniciarPartida(); // Inicia a primeira mão do novo jogo
    }

    // --- Função Revelar Cartas no Fim ---
    function revelarCartasMaquinaFimJogo() {
         if (!elMaoMaquina) return;
         const maoParaRevelar = [...maoMaquina]; // Copia as cartas restantes
         elMaoMaquina.innerHTML = ''; // Limpa a área da mão da máquina
         if (maoParaRevelar.length > 0) {
             // Cria elementos de carta visíveis para as cartas que sobraram
             maoParaRevelar.forEach(carta => {
                 const div = criarElementoCarta(carta);
                 div.style.cursor = 'default'; // Não clicável
                 div.style.opacity = '0.8'; // Levemente transparente
                 elMaoMaquina.appendChild(div);
             });
         } else {
              // Mensagem se não sobraram cartas
              elMaoMaquina.innerHTML = '<span style="font-size:0.9rem; opacity: 0.7;">(Sem cartas restantes)</span>';
         }
     }

    // --- Início do Jogo e Configuração do Menu ---
    document.addEventListener('DOMContentLoaded', () => {
         // Tenta obter hora local de SP para log, fallback para hora local
         let agora = new Date();
         try {
             agora = new Date(agora.toLocaleString('en-US', { timeZone: 'America/Sao_Paulo' }));
         } catch (e) { console.warn("Não foi possível obter hora de São Paulo, usando hora local.");}
         console.log("Truco Paulista Carregado - Mogi Guaçu, SP: " + agora.toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' }));


         // <<< Cache dos elementos da UI (Menu, Regras, Jogo) >>>
         menuInicio = document.getElementById('menu-inicio');
         regrasJogo = document.getElementById('regras-jogo');
         botaoJogarMenu = document.getElementById('botao-jogar-menu');
         botaoRegrasMenu = document.getElementById('botao-regras-menu');
         botaoVoltarMenu = document.getElementById('botao-voltar-menu');
         mesaJogo = document.getElementById('mesa'); // Referência à div da mesa

         elMaoJogador=document.getElementById('mao-jogador');
         elMaoMaquina=document.getElementById('mao-maquina');
         elJogadaJogador=document.getElementById('jogada-jogador');
         elJogadaMaquina=document.getElementById('jogada-maquina');
         elCartaVirada=document.getElementById('carta-virada-display');
         elManilhaInfo=document.getElementById('manilha-info');
         elPlacarFinal=document.getElementById('placar-final');
         elValorMaoAtual=document.getElementById('valor-mao-atual');
         elBotaoTruco=document.getElementById('botao-truco');
         elMensagemTruco=document.getElementById('mensagem-truco');
         elRespostaTruco=document.getElementById('resposta-truco');
         elFimJogoControles=document.getElementById('fim-jogo-controles');

         // Verifica se todos os elementos essenciais foram encontrados para evitar erros
         const elementosEssenciais = [
             menuInicio, regrasJogo, botaoJogarMenu, botaoRegrasMenu, botaoVoltarMenu, mesaJogo,
             elMaoJogador,elMaoMaquina,elJogadaJogador,elJogadaMaquina,elCartaVirada,elManilhaInfo,
             elPlacarFinal,elValorMaoAtual,elBotaoTruco,elMensagemTruco,elRespostaTruco,elFimJogoControles
         ];
         if (elementosEssenciais.some(el => !el)) {
             console.error("ERRO GRAVE: Um ou mais elementos essenciais da UI (Menu ou Jogo) não foram encontrados! Verifique os IDs no HTML.");
             alert("Erro ao carregar a interface do jogo. Verifique o console (F12) para detalhes.");
             return; // Impede a execução do resto do script
         }

         // <<< Lógica dos botões do Menu >>>
         botaoJogarMenu.addEventListener('click', () => {
             menuInicio.style.display = 'none'; // Esconde menu
             regrasJogo.style.display = 'none'; // Esconde regras (caso estivessem abertas)
             mesaJogo.style.display = 'flex'; // <<< MOSTRA a mesa do jogo usando flexbox
             // jogoEmAndamento = true; // Não precisa, iniciarPartida fará isso
             iniciarPartida(); // <<< INICIA o jogo AGORA que o botão foi clicado
         });

         botaoRegrasMenu.addEventListener('click', () => {
             menuInicio.style.display = 'none'; // Esconde menu
             regrasJogo.style.display = 'flex'; // Mostra regras (como flex para centralizar)
         });

         botaoVoltarMenu.addEventListener('click', () => {
             regrasJogo.style.display = 'none'; // Esconde regras
             menuInicio.style.display = 'flex'; // Mostra menu inicial novamente
         });

         // --- Configuração Inicial (antes do jogo começar) ---
         // iniciarPartida(); // << REMOVIDO daqui! O jogo só começa ao clicar em "Jogar"
         console.log("Interface carregada. Menu inicial exibido.");
         atualizarBotoesTruco(); // Garante estado inicial correto dos botões de truco (desabilitados)
         mostrarPlacar(); // Mostra placar inicial (0 a 0)
         renderizarMaoMaquinaReal(); // Mostra as costas das cartas da máquina
    });
</script>
</body>
</html>