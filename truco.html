<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Truco Paulista Pro</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Creepster&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* --- Configurações Globais e Variáveis CSS --- */
    :root {
      --cor-fundo-mesa: #004d00;
      --cor-fundo-mesa-grad: linear-gradient(135deg, #003300, #006400);
      --cor-texto-principal: #f0f0f0;
      --cor-carta-fundo: #fff;
      --cor-carta-borda: #333;
      --cor-carta-verso: linear-gradient(135deg, #555, #888);
      --cor-naipe-vermelho: #c00;
      --cor-naipe-preto: #111;
      --cor-botao-primario: #ffc107;
      --cor-botao-primario-hover: #e0a800;
      --cor-botao-sucesso: #28a745;
      --cor-botao-sucesso-hover: #218838;
      --cor-botao-perigo: #dc3545;
      --cor-botao-perigo-hover: #c82333;
      --cor-botao-info: #007bff;
      --cor-botao-info-hover: #0056b3;
      --cor-botao-secundario: #6c757d;
      --cor-botao-secundario-hover: #5a6268;
      --cor-destaque: #ffeb3b;
      --cor-fundo-overlay-escuro: rgba(0, 0, 0, 0.65);
      --cor-borda-overlay: rgba(255, 255, 255, 0.15);
      --sombra-overlay: 0 3px 8px rgba(0,0,0,0.5);
      --sombra-carta: 2px 4px 8px rgba(0,0,0,0.4);
      --sombra-carta-hover: 4px 8px 12px rgba(0,0,0,0.5);
    }
    /* --- Estilos Gerais --- */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      background-color: var(--cor-fundo-mesa);
      background-image: radial-gradient(rgba(255,255,255,0.03) 1px, transparent 1px);
      background-size: 5px 5px;
      color: var(--cor-texto-principal);
      font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      text-align: center;
      overflow: hidden;
      min-height: 100vh;
    }
   
    html, body {
  height: 100%;
}
    /* --- ESTILOS DO NOVO MENU --- */
    #menu-inicio, #regras-jogo {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: var(--cor-fundo-mesa-grad);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
        padding: 20px;
        text-align: center;
        color: var(--cor-texto-principal);
        backdrop-filter: blur(3px);
        position: relative;
    }
    /* Estilos do Título */
    #menu-inicio h1 {
        font-family: 'Creepster', cursive;
        font-size: 5rem;
        margin-bottom: 30px;
        color: var(--cor-destaque);
        text-shadow: 4px 4px 8px rgba(0,0,0,0.8);
        animation: pulso-titulo 2s ease-in-out infinite alternate;
    }
    /* Animação do Título */
    @keyframes pulso-titulo {
      from { transform: scale(1); text-shadow: 4px 4px 8px rgba(0,0,0,0.8); }
      to { transform: scale(1.05); text-shadow: 6px 6px 12px rgba(0,0,0,0.9); }
    }
          /* Estilos para os Botões (Novos) */
    .botao-menu {
        position: relative;
        overflow: hidden;
        padding: 18px 45px;
        font-size: 1.6rem;
        font-weight: bold;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        transition: transform 0.25s ease-out, box-shadow 0.25s ease, filter 0.25s ease;
        box-shadow: 0 5px 10px rgba(0,0,0,0.4);
        filter: drop-shadow(0 0 5px rgba(0,0,0,0.2));
        margin: 15px;
        min-width: 250px;
        color: white;
        text-transform: uppercase;
        letter-spacing: 2px;
        text-shadow: 1px 1px 2px black;
        border: 2px solid rgba(255, 255, 255, 0.15); /* Borda mais sutil */
    }
    .botao-menu::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 50%, rgba(255,255,255,0.2) 100%);
        transform: translateY(-100%);
        transition: transform 0.5s ease-out;
    }
    .botao-menu:hover::before {
        transform: translateY(0);
    }
    .botao-menu:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 20px rgba(0,0,0,0.6);
        filter: drop-shadow(0 0 10px rgba(255,255,255,0.7)); /* Brilho branco */
    }
    .botao-menu:active {
        transform: scale(0.97);
        box-shadow: 0 3px 8px rgba(0,0,0,0.5);
        filter: drop-shadow(0 0 3px rgba(0,0,0,0.2));
    }
    /* Estilos específicos para cada botão mantidos */
    #botao-jogar-menu {
        background-color: var(--cor-botao-sucesso);
        border-color: var(--cor-botao-sucesso-hover); /* Borda da cor do hover */
    }
    #botao-jogar-menu:hover {
        background-color: var(--cor-botao-sucesso-hover);
        border-color: var(--cor-botao-sucesso);
    }
    #botao-regras-menu {
        background-color: var(--cor-botao-info);
        border-color: var(--cor-botao-info-hover); /* Borda da cor do hover */
    }
    #botao-regras-menu:hover {
        background-color: var(--cor-botao-info-hover);
        border-color: var(--cor-botao-info);
    }
    /* Efeito de Cartas de Fundo */
    .fundo-carta {
        position: absolute;
        width: 100px;
        height: 140px;
        background: var(--cor-carta-verso);
        border: 2px solid #222;
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        opacity: 0.1;
        z-index: -1;
        animation: flutuar-carta 25s linear infinite;
    }
    .fundo-carta:nth-child(1) { top: 15%; left: 10%; transform: rotate(15deg); animation-delay: 0s; }
    .fundo-carta:nth-child(2) { top: 60%; left: 85%; transform: rotate(-25deg); animation-delay: -5s; }
    .fundo-carta:nth-child(3) { bottom: 5%; left: 30%; transform: rotate(5deg); animation-delay: -10s; }
    .fundo-carta:nth-child(4) { top: 25%; right: 5%; transform: rotate(-10deg); animation-delay: -15s; }
    @keyframes flutuar-carta {
      0% { transform: translateY(0) rotate(var(--rotacao-inicial)); }
      50% { transform: translateY(-20px) rotate(var(--rotacao-final)); }
      100% { transform: translateY(0) rotate(var(--rotacao-inicial)); }
    }
    .fundo-carta:nth-child(1) { --rotacao-inicial: 15deg; --rotacao-final: 20deg; }
    .fundo-carta:nth-child(2) { --rotacao-inicial: -25deg; --rotacao-final: -30deg; }
    .fundo-carta:nth-child(3) { --rotacao-inicial: 5deg; --rotacao-final: 10deg; }
    .fundo-carta:nth-child(4) { --rotacao-inicial: -10deg; --rotacao-final: -15deg; }
    /* --- Estilos do Jogo e Regras --- */
    #mesa, #regras-jogo {
      display: none;
      flex-direction: column;
      height: 100vh;
      justify-content: space-between;
      padding: 15px;
      position: relative;
    }
    #regras-jogo {
      justify-content: flex-start;
      overflow-y: auto;
      text-align: left;
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: var(--cor-fundo-mesa-grad);
      padding: 20px;
      backdrop-filter: blur(3px);
      z-index: 100;
    }
    #regras-jogo h2 {
        text-align: center;
        font-size: 2.2rem;
        margin-bottom: 25px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    #regras-jogo .regras-content {
        background-color: rgba(0, 0, 0, 0.4);
        padding: 20px 30px;
        border-radius: 12px;
        max-width: 700px;
        width: 90%;
        margin-bottom: 25px;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    #regras-jogo p, #regras-jogo li { line-height: 1.7; margin-bottom: 12px; }
    #regras-jogo ul { padding-left: 25px; margin-bottom: 18px; }
    #regras-jogo strong { color: var(--cor-destaque); font-weight: 700; }
    #botao-voltar-menu {
       background-color: var(--cor-botao-perigo);
       margin-top: 20px;
       align-self: center;
    }
    #botao-voltar-menu:hover { background-color: var(--cor-botao-perigo-hover); }

    /* --- ESTILOS DO JOGO (Mesa) --- */
    #mesa {
      display: none; /* Começa escondido, JS controla */
      flex-direction: column;
      height: 100vh;
      justify-content: space-between;
      padding: 15px;
      position: relative;
    }

    /* Indicador de Turno Ativo */
    @keyframes glow {
      0%, 100% { box-shadow: 0 0 5px 2px rgba(255, 255, 100, 0.4); }
      50% { box-shadow: 0 0 15px 5px rgba(255, 255, 100, 0.7); }
    }
    .turno-ativo {
      animation: glow 1.8s infinite ease-in-out;
      border-radius: 15px; /* Para o brilho se espalhar bem na área da mão */
    }

    .mao {
      display: flex;
      justify-content: center;
      gap: 15px; /* Mais espaço entre cartas */
      padding: 20px 15px;
      min-height: 150px; /* Altura maior para cartas */
      align-items: center;
      transition: box-shadow 0.5s ease-in-out; /* Transição para o brilho do turno */
      position: relative; /* Para z-index se necessário */
      z-index: 5;
    }
    #mao-maquina { justify-content: center; }
    #mao-jogador { justify-content: center; }

    .carta {
      background: var(--cor-carta-fundo);
      color: var(--cor-naipe-preto); /* Cor padrão, será sobrescrita */
      border: 1px solid var(--cor-carta-borda);
      min-width: 80px;  /* Largura aumentada */
      min-height: 120px; /* Altura aumentada */
      padding: 10px; /* Padding interno */
      border-radius: 10px; /* Cantos arredondados */
      font-size: 2rem; /* Tamanho do valor/naipe */
      font-weight: bold;
      cursor: pointer;
      box-shadow: var(--sombra-carta);
      transition: transform 0.25s ease-out, box-shadow 0.25s ease-out, filter 0.2s ease-out, width 0.2s, height 0.2s;
      display: flex; /* Para alinhar valor e naipe */
      flex-direction: column;
      justify-content: center; /* Centraliza conteúdo verticalmente */
      align-items: center;     /* Centraliza conteúdo horizontalmente */
      user-select: none;
      position: relative; /* Para pseudo-elementos se necessário */
    }

    /* Cores dos Naipes */
    .carta.naipe-copas, .carta.naipe-ouros { color: var(--cor-naipe-vermelho); }
    .carta.naipe-espadas, .carta.naipe-paus { color: var(--cor-naipe-preto); }

    /* Estilo para o valor e naipe dentro da carta */
    .carta .valor { font-size: 2.2rem; line-height: 1; }
    .carta .naipe { font-size: 1.8rem; margin-top: 5px; }

    /* Carta Escondida (Verso) */
    .carta.escondida {
      background: var(--cor-carta-verso);
      /* Padrão de linhas diagonais para o verso */
      background-image: repeating-linear-gradient(
        45deg,
        rgba(255,255,255,0.1),
        rgba(255,255,255,0.1) 10px,
        rgba(0,0,0,0.1) 10px,
        rgba(0,0,0,0.1) 20px
      );
      color: transparent;
      border-color: #222;
      cursor: default;
    }
    .carta.escondida .valor, .carta.escondida .naipe { display: none; } /* Esconde texto */

    /* Efeito Hover nas cartas do jogador (não escondidas) */
    #mao-jogador .carta:hover:not(.escondida):not(.carta-revelada) { /* Não aplica hover em carta revelada da maq */
      transform: translateY(-10px) scale(1.03); /* Levanta mais e aumenta um pouco */
      box-shadow: var(--sombra-carta-hover);
    }

    /* Estilo para cartas jogáveis (brilho sutil) */
    .carta.carta-jogavel:not(.escondida) {
      filter: brightness(1.1);
      /* O cursor pointer já está em .carta, não precisa redefinir */
    }
     /* Remove cursor pointer de cartas não jogáveis na mão do jogador */
    #mao-jogador .carta:not(.carta-jogavel):not(.escondida) {
         cursor: default;
         filter: brightness(0.9); /* Leve escurecida */
    }

     /* Cartas reveladas da máquina no fim */
     #mao-maquina .carta.carta-revelada { /* Combinação das classes */
         opacity: 0.8;
         cursor: default;
         box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
         transform: none; /* Garante que não haja transform */
         filter: none; /* Garante que não haja filter */
     }
     #mao-maquina .mensagem-sem-cartas { /* Estilo da mensagem */
         font-size: 0.9rem;
         opacity: 0.7;
         color: #ccc;
         font-style: italic;
         padding: 20px; /* Adiciona padding para centralizar melhor */
     }

    #centro {
      display: flex;
      justify-content: space-around;
      align-items: center;
      gap: 20px;
      margin: 15px 0;
      min-height: 180px; /* Altura mínima aumentada */
      flex-grow: 1;
      padding: 0 25px;
      position: relative;
      z-index: 1;
    }

   /* Placeholder para cartas jogadas */
   #jogada-maquina, #jogada-jogador {
      width: 90px; /* Largura fixa */
      height: 130px; /* Altura fixa */
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.2);
      border: 2px dashed rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      transition: background-color 0.3s;
    }

    /* Carta jogada preenche o placeholder */
    #jogada-maquina .carta, #jogada-jogador .carta {
        width: 90px;          /* Tamanho exato do placeholder */
        height: 130px;         /* Tamanho exato do placeholder */
        min-width: auto;       /* Override min-width */
        min-height: auto;      /* Override min-height */
        transform: none;       /* Remove scale/translate de hover */
        box-shadow: var(--sombra-carta); /* Sombra normal, sem efeito hover */
        cursor: default;       /* Cursor padrão */
        filter: none;          /* Remove filtros como brightness */
    }
    /* Ajuste da fonte dentro da carta jogada para caber */
    #jogada-maquina .carta .valor, #jogada-jogador .carta .valor { font-size: 2rem; }
    #jogada-maquina .carta .naipe, #jogada-jogador .carta .naipe { font-size: 1.6rem; }

    #info-centro {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        min-width: 120px;
    }

     #valor-mao-atual {
        font-size: 1.2rem;
        font-weight: bold;
        background-color: var(--cor-fundo-overlay-escuro);
        padding: 6px 12px;
        border-radius: 8px;
        margin-bottom: 8px;
        box-shadow: var(--sombra-overlay);
        border: 1px solid var(--cor-borda-overlay);
    }

    /* Display da Vira e Manilha */
     #carta-virada-display {
         min-height: 130px; /* Altura similar à carta jogada */
         display: flex;
         align-items: center;
         justify-content: center;
         margin-bottom: 5px; /* Espaço antes da Manilha */
     }
     #carta-virada-display .carta { /* Estilo específico para a VIRA */
         cursor: default;
         transform: scale(0.9); /* Um pouco menor que as cartas normais */
         border: 3px solid transparent; /* Borda base */
         box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.7); /* Sombra base para animação */
         animation: pulse-vira 2s infinite;
     }
     /* Animação para destacar a Vira */
     @keyframes pulse-vira {
         0% { box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.7); border-color: rgba(255, 235, 59, 0.7); }
         70% { box-shadow: 0 0 10px 15px rgba(255, 235, 59, 0); border-color: rgba(255, 235, 59, 0); }
         100% { box-shadow: 0 0 0 0 rgba(255, 235, 59, 0); border-color: rgba(255, 235, 59, 0); }
     }

     #manilha-info {
         font-size: 1.2rem;
         font-weight: bold;
         background-color: rgba(255, 235, 59, 0.2); /* Fundo amarelo transparente */
         color: var(--cor-destaque);
         padding: 5px 10px;
         border-radius: 6px;
         text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
     }

    #rodadas {
      position: absolute;
      top: 15px;
      right: 15px;
      display: flex;
      gap: 8px;
      z-index: 10; /* Acima do placar */
    }

    .bolinha {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.8);
      background: rgba(0,0,0,0.3); /* Fundo escuro antes de preencher */
      transition: background-color 0.5s ease-in-out, border-color 0.5s ease-in-out;
      position: relative; /* Para pseudo-elemento */
      overflow: hidden; /* Para conter o ::before */
    }
    /* Estilo interno para animação de preenchimento */
    .bolinha::before {
        content: '';
        position: absolute;
        top: 50%; left: 50%;
        width: 0; height: 0; /* Começa invisível no centro */
        border-radius: 50%;
        background-color: transparent;
        transition: width 0.4s ease-out, height 0.4s ease-out, background-color 0.4s ease-out;
        transform: translate(-50%, -50%);
    }

    /* Quando 'preenchendo' é adicionado, o ::before cresce */
    .bolinha.preenchendo::before {
        width: calc(100% - 0px); /* Tamanho interno (ajustar se borda mudar) */
        height: calc(100% - 0px);
    }

    /* Cores do ::before baseado na classe de resultado */
    .empate::before { background-color: orange; }
    .vencedor-jogador::before { background-color: #007bff; } /* Azul para jogador */
    .vencedor-maquina::before { background-color: #dc3545; } /* Vermelho para máquina */

    /* Placar no canto superior esquerdo */
    #placar-final {
      position: absolute;
      top: 5px; /* Ajuste para alinhar com bolinhas */
      left: 15px;
      font-size: 1rem;
      font-weight: bold;
      background-color: var(--cor-fundo-overlay-escuro);
      padding: 6px 10px;
      border-radius: 6px;
      box-shadow: var(--sombra-overlay);
      border: 1px solid var(--cor-borda-overlay);
      z-index: 10;
      color: var(--cor-texto-principal);
    }

    /* --- Controles de Truco (Visual 2 aplicado) --- */
    #truco-controles {
      position: absolute;
      bottom: 165px; /* Ajustado para mais espaço da mão */
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      z-index: 20;
      min-width: 300px;
      width: 90%; /* Ocupa mais largura em telas menores */
      max-width: 450px; /* Limite máximo */
      text-align: center;
    }

    /* Mensagem com fundo próprio */
    #mensagem-truco {
      font-size: 1.1rem;
      font-weight: bold;
      min-height: 30px;
      width: 100%;
      padding: 8px 12px;
      margin-bottom: 10px;
      color: var(--cor-destaque);
      text-shadow: 1px 1px 3px black;
      line-height: 1.4;
      background-color: var(--cor-fundo-overlay-escuro);
      border-radius: 8px;
      border: 1px solid var(--cor-borda-overlay);
      box-shadow: var(--sombra-overlay);
      display: flex; /* Usar flex para centralizar texto */
      align-items: center;
      justify-content: center;
    }
    /* Esconder a área da mensagem se vazia */
     #mensagem-truco:empty {
        display: none;
        margin-bottom: 0; /* Remove margem quando escondido */
     }

    /* Botão principal de pedir aposta */
    #botao-truco {
      padding: 10px 20px;
      font-size: 0.8rem;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s ease-out, transform 0.1s ease-out, box-shadow 0.2s ease;
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      background-color: var(--cor-botao-primario);
      color: #333; /* Texto escuro em botão claro */
      min-width: 80px;
      display: flex; /* Mantido flex se precisar de ícone depois */
      align-items: center;
      justify-content: center;
      gap: 5px;
      /* Ordem no flex layout do #truco-controles */
      order: 2; /* Mensagem (1), Botão Truco (2), Respostas (3), Jogar Novamente (4) */
    }
    #botao-truco:hover:not(:disabled) { background-color: var(--cor-botao-primario-hover); }

    /* Container dos botões de resposta com fundo */
    #resposta-truco {
       display: flex;
       gap: 10px;
       flex-wrap: wrap;
       justify-content: center;
       min-height: 44px; /* Altura aprox. do botão para evitar pulo */
       width: 100%;
       padding: 10px;
       margin-top: 5px;
       background-color: var(--cor-fundo-overlay-escuro);
       border-radius: 8px;
       border: 1px solid var(--cor-borda-overlay);
       box-shadow: var(--sombra-overlay);
       /* Ordem no flex layout */
       order: 3;
    }
    /* Esconder a área de resposta se estiver vazia */
    #resposta-truco:empty {
        display: none; /* Esconde completamente */
        padding: 0;
        min-height: 0;
        margin-top: 0;
    }
    #resposta-truco button {
        margin: 0;
        padding: 10px 15px;
        font-size: 1rem;
        font-weight: bold;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.2s ease-out, transform 0.1s ease-out, box-shadow 0.2s ease;
        box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        color: white;
    }

    /* Ações nos botões */
     #truco-controles button:active:not(:disabled) {
        transform: scale(0.98);
        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
     }
     #truco-controles button:disabled {
        background-color: #888 !important; /* Cor cinza forte para desabilitado */
        color: #ccc !important;
        cursor: not-allowed;
        opacity: 0.6;
        box-shadow: none;
        transform: none;
     }

    /* Botões de Resposta específicos */
    #botao-aceitar-truco { background-color: var(--cor-botao-sucesso); }
    #botao-aceitar-truco:hover { background-color: var(--cor-botao-sucesso-hover); }
    #botao-recusar-truco { background-color: var(--cor-botao-perigo); }
    #botao-recusar-truco:hover { background-color: var(--cor-botao-perigo-hover); }
    #botao-aumentar-aposta { background-color: var(--cor-botao-info); }
    #botao-aumentar-aposta:hover { background-color: var(--cor-botao-info-hover); }

     /* Botão Jogar Novamente */
     #fim-jogo-controles {
         display: none; /* Escondido inicialmente */
         margin-top: 10px;
         width: 100%;
         /* Ordem no flex layout */
         order: 4;
     }
     #botao-jogar-novamente {
        padding: 10px 20px;
        font-size: 1.1rem;
        font-weight: bold;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.2s ease-out, transform 0.1s ease-out, box-shadow 0.2s ease;
        box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        color: white;
        background-color: var(--cor-botao-secundario);
     }
     #botao-jogar-novamente:hover { background-color: var(--cor-botao-secundario-hover); }

/* --- NOVO ESTILO: Mão de Onze Modal (Card Flutuante) --- */
#mao-onze-overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    /* Deixamos o fundo transparente ou muito leve, o modal será o card */
    background-color: rgba(0, 0, 0, 0.05); /* Escurece o mínimo, sem blur */
    display: flex;
    justify-content: center;
    align-items: flex-start; /* Alinha no topo */
    padding-top: 15vh; /* Distância do topo para posicionar melhor */
    z-index: 1000;
    pointer-events: auto; /* Garante que o clique funciona */
}

#mao-onze-modal {
    background: #2c3e50;
    padding: 20px;
    border-radius: 12px;
    text-align: center;
    color: white;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.7), 0 0 0 5px rgba(255, 255, 255, 0.1); /* Sombra e borda de destaque */
    border: 2px solid var(--cor-destaque); /* Borda amarela para destaque */
    max-width: 90%;
    width: 350px; /* Tornando o card um pouco menor */
    animation: scale-in 0.3s ease-out;
}

@keyframes scale-in {
    from { transform: scale(0.7); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}

#mao-onze-modal h2 {
    font-size: 1.8rem; /* Um pouco menor */
    margin-bottom: 10px;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    color: var(--cor-destaque);
}

#mao-onze-modal p {
    font-size: 1.05rem; /* Um pouco menor */
    margin-bottom: 20px;
}

#mao-onze-botoes {
    display: flex;
    justify-content: space-around;
    gap: 10px;
}

#mao-onze-botoes button {
    padding: 10px 20px;
    font-size: 1.1rem;
    font-weight: bold;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

#botao-onze-jogar {
    background-color: var(--cor-botao-sucesso);
    color: white;
}

#botao-onze-jogar:hover { background-color: var(--cor-botao-sucesso-hover); }

#botao-onze-correr {
    background-color: var(--cor-botao-perigo);
    color: white;
}

#botao-onze-correr:hover { background-color: var(--cor-botao-perigo-hover); }

  </style>
</head>
<body>

  <div id="menu-inicio">
    <div class="fundo-carta"></div>
    <div class="fundo-carta"></div>
    <div class="fundo-carta"></div>
    <div class="fundo-carta"></div>
    <h1>Truco Paulista</h1>
    <button id="botao-jogar-menu" class="botao-menu">Jogar</button>
    <button id="botao-regras-menu" class="botao-menu">Regras</button>
  </div>

  <div id="regras-jogo">
    <h2>Regras do Truco Paulista</h2>
    <div class="regras-content">
       <p><strong>Objetivo:</strong> Ser a primeira dupla (ou jogador, neste caso contra a máquina) a alcançar 12 pontos.</p>
       <p><strong>Baralho:</strong> Utiliza-se um baralho espanhol limpo (sem 8, 9, 10 e coringas) ou um baralho francês adaptado, removendo essas cartas.</p>
       <p><strong>Cartas e Força (Manilhas):</strong></p>
       <ul>
         <li>A cada mão, uma carta é virada ("vira"). A carta seguinte na sequência de valores define as <strong>manilhas</strong> (as cartas mais fortes daquela mão).</li>
         <li>Ordem de força das manilhas (da mais forte para a mais fraca): <strong>Paus (Zap) ♣️ > Copas ♥️ > Espadas ♠️ > Ouros ♦️</strong>.</li>
         <li>Se a vira for um 3, as manilhas serão os 4s, seguindo a ordem de naipes acima.</li>
       </ul>
        <p><strong>Cartas Comuns (Força Normal - da mais forte para a mais fraca):</strong></p>
        <ul>
          <li><strong>3 > 2 > A (Ás) > K (Rei) > J (Valete) > Q (Dama) > 7 > 6 > 5 > 4</strong></li>
          <li>Cartas de mesmo valor têm a mesma força (ex: um 7♦️ empata com um 7♠️, se não forem manilhas).</li>
        </ul>
       <p><strong>Como Jogar:</strong></p>
       <ul>
         <li>Cada jogador recebe 3 cartas.</li>
         <li>A mão é disputada em melhor de 3 rodadas. Quem ganhar 2 rodadas vence a mão.</li>
         <li>Em cada rodada, cada jogador joga uma carta. A carta de maior força vence a rodada.</li>
         <li>Se a primeira rodada empatar, quem ganhar a segunda vence a mão.</li>
         <li>Se a segunda rodada empatar, quem ganhou a primeira vence a mão.</li>
         <li>Se a primeira e a segunda rodadas empatarem, quem ganhar a terceira vence a mão.</li>
         <li>Se as três rodadas empatarem ("cangar"), ninguém marca pontos na mão.</li>
         <li>Quem vence a rodada começa jogando na próxima.</li>
         <li> **Modificado:** Quem vence a *mão* começa jogando a *próxima mão*. Se empatar, o jogador humano começa.</li>
       </ul>
       <p><strong>Pontuação e Truco:</strong></p>
       <ul>
         <li>Uma mão normal vale <strong>1 ponto</strong>.</li>
         <li>Um jogador pode pedir <strong>"Truco!"</strong> a qualquer momento antes de jogar sua carta na sua vez. Isso aumenta o valor da mão para <strong>3 pontos</strong>.</li>
         <li>O adversário pode:
             <ul>
                 <li><strong>Aceitar:</strong> A mão passa a valer 3 pontos.</li>
                 <li><strong>Recusar ("Correr"):</strong> Quem pediu truco ganha 1 ponto.</li>
                 <li><strong>Pedir "Seis!" (ou "Meio-Pau"):</strong> Aumenta a aposta para 6 pontos.</li>
             </ul>
         </li>
         <li>Se "Seis" for pedido, o jogador que pediu "Truco" pode aceitar (mão vale 6), recusar (adversário ganha 3 pontos) ou pedir <strong>"Nove!"</strong>.</li>
         <li>Se "Nove" for pedido, o outro jogador pode aceitar (mão vale 9) ou recusar (adversário ganha 6 pontos).</li>
          <li>Se "Doze" for pedido (geralmente quando já se tem 9 pontos), o outro jogador pode aceitar (mão vale 12 - e o jogo acaba se o placar permitir) ou recusar (adversário ganha 9 pontos).</li>
         <li>**Mão de Onze:** Quando uma dupla (ou jogador) atinge 11 pontos, a próxima mão vale 3 pontos automaticamente. Os jogadores olham as cartas e decidem se jogam (aceitam) ou correm (dão 1 ponto ao adversário). Nesta mão especial, não é permitido pedir truco. (Esta regra específica da Mão de Onze não está implementada neste código, a aposta pode ser aumentada normalmente).</li>
       </ul>
    </div>
    <button id="botao-voltar-menu" class="botao-menu">Voltar</button>
  </div>

  <div id="mesa">
    <div id="placar-final">Placar: Você 0 x 0 Máquina</div>
    <div id="rodadas">
       <div class="bolinha" id="bolinha-rodada1"></div>
       <div class="bolinha" id="bolinha-rodada2"></div>
       <div class="bolinha" id="bolinha-rodada3"></div>
     </div>

    <div class="mao" id="mao-maquina"></div> <div id="centro">
      <div id="jogada-maquina"></div>
      <div id="info-centro">
          <div id="valor-mao-atual">Vale: 1 ponto</div>
          <div id="carta-virada-display"></div>
          <div id="manilha-info">Manilha: ?</div>
      </div>
      <div id="jogada-jogador"></div>
    </div>
   
    <div id="mao-onze-overlay" style="display: none;">
    <div id="mao-onze-modal">
        <h2>Mão de Onze!</h2>
        <p>A mão vale 3 pontos. Você quer jogar ou correr?</p>
        <div id="mao-onze-botoes">
            <button id="botao-onze-jogar">Jogar</button>
            <button id="botao-onze-correr">Correr</button>
        </div>
    </div>
</div>

    <div class="mao" id="mao-jogador"></div> <div id="truco-controles">
        <div id="mensagem-truco"></div> <button id="botao-truco" onclick="pedirApostaJogador()" disabled>Truco!</button>
        <div id="resposta-truco"></div>
        <div id="fim-jogo-controles" style="display: none;">
            <button id="botao-jogar-novamente" onclick="jogarNovamente()">Jogar Novamente</button>
        </div>
    </div>
  </div>

<script>
    // --- Constantes Globais ---
    const NAIPES = ['♦️', '♠️', '♥️', '♣️'];
    // <<< ADICIONADO do Visual 2: Mapeamento para classes CSS >>>
    const NAIPE_CLASSES = { '♦️': 'ouros', '♠️': 'espadas', '♥️': 'copas', '♣️': 'paus' };
    const VALORES = [4, 5, 6, 7, 'Q', 'J', 'K', 'A', 2, 3];
    const VALOR_MAP = { 4: 4, 5: 5, 6: 6, 7: 7, 'Q': 10, 'J': 11, 'K': 12, 'A': 13, 2: 14, 3: 15 };
    const PONTOS_VITORIA = 12;

    // --- Níveis de Aposta e Pontuações (Lógica 1) ---
    const NIVEIS_APOSTA = {
        NORMAL: { valor: 1, proximo: 'TRUCO', nomeDisplay: 'Mão',    recusaPaga: 1 },
        TRUCO:  { valor: 3, proximo: 'SEIS',  nomeDisplay: 'Truco',  recusaPaga: 1 },
        SEIS:   { valor: 6, proximo: 'NOVE',  nomeDisplay: 'Seis',   recusaPaga: 3 },
        NOVE:   { valor: 9, proximo: 'DOZE',  nomeDisplay: 'Nove',   recusaPaga: 6 },
        DOZE:   { valor: 12, proximo: null,   nomeDisplay: 'Doze',   recusaPaga: 9 }
    };

    // --- Variáveis Globais de Estado (Lógica 1) ---
    let baralho = [];
    let maoJogador = [], maoMaquina = [];
    let manilhaValor, vira;
    let rodadaAtual = 1, vitoriasRodadaJogador = 0, vitoriasRodadaMaquina = 0, empatesRodada = 0;
    let jogadorDaVez = 'jogador', quemIniciouRodada = 'jogador';
    let cartaJogadaCentroJogador = null, cartaJogadaCentroMaquina = null;
    let pontuacaoJogador = 0, pontuacaoMaquina = 0;
    let podeJogar = false, jogoEmAndamento = false;
    let vencedorDaMaoAnterior = 'jogador';
   let elMaoOnzeOverlay, elBotaoOnzeJogar, elBotaoOnzeCorrer;
  

    // --- Variáveis de Estado do Truco (Lógica 1) ---
    let nivelApostaAtual = 'NORMAL';
    let pontosDaMaoAtual = NIVEIS_APOSTA.NORMAL.valor;
    let estadoTruco = 'normal';
    let quemPediuUltimaAposta = null;
    // <<< ADICIONADO do Visual 2: Controle de timeout da mensagem >>>
    let timeoutMensagem = null;

    // --- Elementos da UI (cache - Lógica 1) ---
    let menuInicio, regrasJogo, botaoJogarMenu, botaoRegrasMenu, botaoVoltarMenu, mesaJogo;
    let elMaoJogador, elMaoMaquina, elJogadaJogador, elJogadaMaquina, elCartaVirada, elManilhaInfo, elPlacarFinal, elValorMaoAtual, elBotaoTruco, elMensagemTruco, elRespostaTruco, elFimJogoControles;

    // --- Funções Auxiliares ---
    function formatarValorDisplay(valor) { return String(valor); }

    // <<< MODIFICADO: Função criarElementoCarta para usar o Visual 2 >>>
    function criarElementoCarta(carta, escondida = false, revelada = false) {
        const div = document.createElement('div');
        div.className = 'carta'; // Classe base

        if (escondida) {
            div.classList.add('escondida');
        } else if (carta && carta.valor && carta.naipe) {
            const naipeClass = `naipe-${NAIPE_CLASSES[carta.naipe]}`; // Pega a classe CSS do naipe
            div.classList.add(naipeClass); // Adiciona classe para cor e identificação
            div.dataset.valor = carta.valor;
            div.dataset.naipe = carta.naipe;

            // Cria spans internos para valor e naipe (requerido pelo CSS do Visual 2)
            const spanValor = document.createElement('span');
            spanValor.className = 'valor';
            spanValor.textContent = formatarValorDisplay(carta.valor);

            const spanNaipe = document.createElement('span');
            spanNaipe.className = 'naipe';
            spanNaipe.textContent = carta.naipe;

            div.appendChild(spanValor);
            div.appendChild(spanNaipe);

            // Adiciona classe específica se for carta revelada da máquina no fim
            if (revelada) {
                 div.classList.add('carta-revelada');
            }
        } else {
            // Caso de carta inválida ou placeholder, mostra como escondida por segurança
            div.classList.add('escondida');
        }
        return div;
    }

    function atualizarValorMaoDisplay() {
        if (elValorMaoAtual) {
            elValorMaoAtual.textContent = `Vale: ${pontosDaMaoAtual} ponto${pontosDaMaoAtual > 1 ? 's' : ''}`;
        }
    }

    // <<< ADICIONADO do Visual 2: Função para indicador de turno >>>
    function atualizarIndicadorTurno() {
        if (!elMaoJogador || !elMaoMaquina) return;
        elMaoJogador.classList.remove('turno-ativo');
        elMaoMaquina.classList.remove('turno-ativo');
        if (jogoEmAndamento && estadoTruco !== 'finalizado' && !estadoTruco.startsWith('pedido_')) { // Não brilha se jogo acabou ou aposta pendente
            if (jogadorDaVez === 'jogador' && podeJogar) { // Só brilha mão do jogador se ele PODE jogar
                elMaoJogador.classList.add('turno-ativo');
            } else if (jogadorDaVez === 'maquina') {
                elMaoMaquina.classList.add('turno-ativo');
            }
        }
    }

    // --- Lógica Principal (Baralho, Cartas, Força - Lógica 1) ---
    function criarBaralho() {
        baralho = [];
        for (let valor of VALORES) {
            for (let naipe of NAIPES) {
                // Adiciona força aqui mesmo
                baralho.push({ valor: valor, naipe: naipe, forca: VALOR_MAP[valor] });
            }
        }
    }
    function embaralhar() {
        for (let i = baralho.length - 1; i > 0; i--) {
            let j = Math.floor(Math.random() * (i + 1));
            [baralho[i], baralho[j]] = [baralho[j], baralho[i]];
        }
    }
    function sortearManilha() {
        if (baralho.length <= 7) { // Usar <= 7 para garantir vira + 6 cartas
            console.warn("Poucas cartas, recriando baralho...");
            criarBaralho();
            embaralhar();
        }
        vira = baralho.pop();
        const indiceVira = VALORES.indexOf(vira.valor);
        manilhaValor = VALORES[(indiceVira + 1) % VALORES.length];

        if (elCartaVirada) {
            elCartaVirada.innerHTML = '';
            // Usa a nova função criarElementoCarta
            const viraDisplay = criarElementoCarta(vira);
            // O CSS do Visual 2 já aplica estilo (cursor, animação) em #carta-virada-display .carta
            elCartaVirada.appendChild(viraDisplay);
        }
        if (elManilhaInfo) {
            elManilhaInfo.textContent = `Manilha: ${formatarValorDisplay(manilhaValor)}`;
        }
        console.log(`Vira: ${formatarValorDisplay(vira.valor)}${vira.naipe}, Manilha: ${formatarValorDisplay(manilhaValor)}`);
    }
    function distribuirCartas() {
        if (baralho.length < 6) {
            console.error("Erro crítico: Sem cartas suficientes para distribuir!");
            return; // Evita erro grave
        }
        maoJogador = baralho.splice(0, 3);
        maoMaquina = baralho.splice(0, 3);
        renderizarMaos(); // Renderiza após distribuir
    }

            // <<< MODIFICADO: renderizarMaos para usar classes visuais do Visual 2 e tratar Mão de Onze/Ferro >>>
    function renderizarMaos() {
        if (!elMaoJogador || !elMaoMaquina) return;
        elMaoJogador.innerHTML = '';

        // Determina se o jogador pode interagir com as cartas
        const maoDeOnzeJogador = estadoTruco === 'mao_de_onze_jogador';
        const maoDeFerro = estadoTruco === 'mao_de_ferro';
       
        // CORREÇÃO AQUI: Permite jogar carta se for o turno, NÃO houver aposta pendente E NÃO for Mão de Onze (que exige decisão antes)
        const jogadorPodeJogarCarta = jogoEmAndamento && podeJogar && jogadorDaVez === 'jogador' &&
                                      !estadoTruco.startsWith('pedido_') && estadoTruco !== 'finalizado' &&
                                      !maoDeOnzeJogador;
        // Na Mão de Ferro, 'maoDeFerro' é true, 'maoDeOnzeJogador' é false, então jogadorPodeJogarCarta será true se for a vez dele.

        maoJogador.forEach((carta, i) => {
            // As cartas do jogador SÓ ficam escondidas na Mão de Ferro
            const deveEsconder = maoDeFerro;
            const div = criarElementoCarta(carta, deveEsconder);
           
            // Habilita a jogabilidade se for o turno normal/ferro do jogador
            if (jogadorPodeJogarCarta) {
                div.classList.add('carta-jogavel');
                div.onclick = () => jogadorJogaCarta(i);
            } else {
                div.classList.remove('carta-jogavel');
                div.onclick = null;
            }
            elMaoJogador.appendChild(div);
        });

        // A máquina também precisa mostrar cartas escondidas na Mão de Ferro
        renderizarMaoMaquinaReal(false, maoDeFerro);

        atualizarIndicadorTurno(); // Atualiza qual mão deve brilhar
    }


    // <<< MODIFICADO: renderizarMaoMaquinaReal para usar Visual 2 >>>
  
  
    function renderizarMaoMaquinaReal(revelar = false, maoDeFerro = false) {
    elMaoMaquina.innerHTML = ''; // Limpa a mão da máquina

    // Mostra as cartas reais da máquina no fim da mão ou do jogo
    if (revelar && maoMaquina.length > 0) {
        maoMaquina.forEach(carta => {
            const div = criarElementoCarta(carta, false, true);
            elMaoMaquina.appendChild(div);
        });
    } else if (maoDeFerro) {
        // Na Mão de Ferro, mostra as 3 cartas viradas para baixo
        for (let i = 0; i < 3; i++) {
            const div = criarElementoCarta({}, true); // O segundo parâmetro true significa carta virada
            elMaoMaquina.appendChild(div);
        }
    } else {
        // Mostra as cartas viradas para baixo durante o jogo normal
        const numCartasVisiveis = maoMaquina.length;
        for (let i = 0; i < numCartasVisiveis; i++) {
            const div = criarElementoCarta({}, true);
            elMaoMaquina.appendChild(div);
        }
        // Adiciona placeholders invisíveis para manter o alinhamento
        const cartasFaltantes = 3 - numCartasVisiveis;
        for (let i = 0; i < cartasFaltantes; i++) {
            const placeholder = document.createElement('div');
            placeholder.classList.add('placeholder-carta');
            elMaoMaquina.appendChild(placeholder);
        }
    }
}

    // --- Funções de Força e Comparação (Lógica 1 - Mantidas) ---
     function calcularForca(carta) {
        if (!carta || !carta.valor) return -1; // Carta inválida ou nula
        const valorBase = carta.forca; // Usa o mapeamento VALOR_MAP

        // Checa se é manilha
        if (carta.valor === manilhaValor) {
            switch (carta.naipe) {
                case '♣️': return 1000; // Zap (Paus)
                case '♥️': return 999;  // Copas
                case '♠️': return 998;  // Espadas
                case '♦️': return 997;  // Ouros (7 Ouros)
                default: return 100; // Segurança
            }
        }
        return valorBase; // Retorna força normal
    }
    function compararCartasInterno(c1, c2) {
        if (!c1 && !c2) return 'empate';
        if (!c1) return 'c2';
        if (!c2) return 'c1';
        const f1 = calcularForca(c1);
        const f2 = calcularForca(c2);
        if (f1 === f2) return 'empate';
        return f1 > f2 ? 'c1' : 'c2';
    }

        // <<< MODIFICADO: atualizarBotoesTruco para usar Visual 2 >>>
    function atualizarBotoesTruco() {
        if (!elBotaoTruco || !elRespostaTruco || !elFimJogoControles || !elMensagemTruco) return;

        const jogoFinalizado = estadoTruco === 'finalizado';

        // Visibilidade dos controles de fim de jogo
        elFimJogoControles.style.display = jogoFinalizado ? 'block' : 'none';

        // Visibilidade do botão principal de aposta
        elBotaoTruco.style.display = jogoFinalizado ? 'none' : 'flex'; // Usar flex para manter alinhamento

        // Limpa área de resposta se jogo acabou ou não há aposta pendente da máquina
        if (jogoFinalizado || !(estadoTruco.startsWith('pedido_') && estadoTruco.endsWith('_maquina'))) {
            elRespostaTruco.innerHTML = '';
            // Esconde a área de resposta vazia (CSS :empty cuida disso)
        }

         // Limpa mensagem principal se jogo acabou e não é a msg final
        if (jogoFinalizado && elMensagemTruco.textContent && !elMensagemTruco.textContent.includes("FIM DE JOGO")) {
              elMensagemTruco.textContent = '';
              // CSS :empty cuida de esconder
        }
        // Garante que a mensagem só aparece se tiver conteúdo (CSS :empty cuida)

        if (!jogoFinalizado) {
            // --- NOVO: Verificação Mão de Onze / Mão de Ferro ---
            const maoEspecial = pontuacaoJogador === 11 || pontuacaoMaquina === 11;
           
            // Lógica para habilitar/desabilitar e texto do botão Truco
            const infoNivelAtual = NIVEIS_APOSTA[nivelApostaAtual];
            const proximoNivelChave = infoNivelAtual.proximo;
            let podePedir = false;

            if (proximoNivelChave && !maoEspecial) { // <--- Adicionado a verificação !maoEspecial para desabilitar o truco no 11
                const infoProximoNivel = NIVEIS_APOSTA[proximoNivelChave];
                elBotaoTruco.textContent = `${infoProximoNivel.nomeDisplay}!`; // Define o texto (Truco!, Seis!, etc.)

                // Pode pedir se: jogo rolando, é vez do jogador, pode jogar carta (podeJogar=true),
                // não há aposta pendente, e (estado normal OU máquina pediu e jogador aceitou)
                podePedir = jogoEmAndamento &&
                            jogadorDaVez === 'jogador' &&
                            podeJogar && // <<< Garante que só pode pedir quando pode jogar carta
                            !estadoTruco.startsWith('pedido_') &&
                            (estadoTruco === 'normal' ||
                             (estadoTruco.startsWith('aceito_') && quemPediuUltimaAposta === 'maquina'));
            } else {
                elBotaoTruco.textContent = maoEspecial ? 'Mão de Onze!' : 'Máximo!';
                podePedir = false; // Não pode pedir no nível máximo ou na Mão de Onze
            }

            elBotaoTruco.disabled = !podePedir;
        }
    }

    // <<< MODIFICADO: mostrarMensagemTruco para usar Visual 2 >>>
    function mostrarMensagemTruco(msg, tempo = 3000) {
        if (!elMensagemTruco) return;

        // Limpa timeout anterior se houver um ativo
        if (timeoutMensagem) {
            clearTimeout(timeoutMensagem);
            timeoutMensagem = null;
        }

        elMensagemTruco.textContent = msg;
        // O CSS com :empty cuida de mostrar/esconder o elemento

        // Condições para NÃO apagar a mensagem automaticamente:
        const eMensagemPersistente = tempo === 0 ||                        // Tempo 0 significa persistente
                                     estadoTruco === 'finalizado' ||        // Mensagem de fim de jogo
                                     estadoTruco.startsWith('pedido_');    // Mensagem esperando resposta

        if (msg && !eMensagemPersistente && tempo > 0) {
            timeoutMensagem = setTimeout(() => {
                // Verifica se a mensagem ainda é a mesma antes de limpar
                // E se o estado não mudou para um que exija mensagem persistente
                if (elMensagemTruco && elMensagemTruco.textContent === msg && !estadoTruco.startsWith('pedido_') && estadoTruco !== 'finalizado') {
                    elMensagemTruco.textContent = ''; // Limpa o texto
                    // CSS :empty cuida de esconder
                }
                timeoutMensagem = null;
            }, tempo);
        }
    }

    // --- Lógica de Jogada de Carta (Lógica 1 com adaptações visuais) ---
    function jogadorJogaCarta(indice) {
        // Revalida se pode jogar AGORA
        const jogadorPodeJogarCarta = jogoEmAndamento && podeJogar && jogadorDaVez === 'jogador' && !estadoTruco.startsWith('pedido_') && estadoTruco !== 'finalizado';
        if (!jogadorPodeJogarCarta) {
             if (estadoTruco.startsWith('pedido_')) {
                mostrarMensagemTruco("Responda à aposta antes de jogar!", 2500);
             }
            console.warn("Jogador tentou jogar carta inválida/fora de hora.");
            return;
        }
        if (indice < 0 || indice >= maoJogador.length) {
            console.error("Índice de carta inválido:", indice);
            return;
        }

        podeJogar = false; // Bloqueia novas ações do jogador imediatamente
        cartaJogadaCentroJogador = maoJogador.splice(indice, 1)[0];
        renderizarMaos(); // Atualiza a mão (remove carta, remove highlight/onclick das restantes)
        console.log(`Jogador jogou: ${formatarValorDisplay(cartaJogadaCentroJogador.valor)}${cartaJogadaCentroJogador.naipe}`);

        // Mostra a carta jogada no centro (placeholder)
        if (elJogadaJogador) {
            elJogadaJogador.innerHTML = ''; // Limpa placeholder
            const cartaEl = criarElementoCarta(cartaJogadaCentroJogador);
            elJogadaJogador.appendChild(cartaEl);
            // Adicionar animação de entrada (opcional, do Visual 2)
            cartaEl.style.opacity = '0';
            cartaEl.style.transform = 'translateY(15px) scale(0.9)';
            requestAnimationFrame(() => {
                 cartaEl.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
                 cartaEl.style.opacity = '1';
                 cartaEl.style.transform = 'translateY(0) scale(1)';
            });
        }

        jogadorDaVez = 'maquina'; // Passa a vez
        quemIniciouRodada = 'jogador'; // Marca quem iniciou esta troca
        atualizarBotoesTruco(); // Atualiza botões (desabilita Truco do jogador)
        atualizarIndicadorTurno(); // Move o brilho para a máquina

        // Decide o próximo passo
        if (!cartaJogadaCentroMaquina) { // Se a máquina ainda não jogou nesta troca
            // A máquina agora vai decidir (pode jogar carta ou pedir truco)
            setTimeout(maquinaDecideJogada, 900 + Math.random() * 500); // Delay para IA "pensar"
        } else { // Ambas as cartas estão na mesa
            setTimeout(finalizarRodada, 500); // Delay curto para comparar as cartas
        }
    }

    function maquinaJogaCarta() {
        // Verifica se a máquina PODE jogar uma carta (não responder aposta)
        const maquinaPodeJogarCarta = jogoEmAndamento && maoMaquina.length > 0 && jogadorDaVez === 'maquina' && !estadoTruco.startsWith('pedido_') && estadoTruco !== 'finalizado';
        if (!maquinaPodeJogarCarta) {
             console.warn(`Máquina impedida de jogar CARTA. Estado: ${estadoTruco}, Vez: ${jogadorDaVez}, Jogo: ${jogoEmAndamento}, Cartas: ${maoMaquina.length}`);
             // Se a máquina está esperando resposta do jogador, ela não faz nada aqui.
             // A função jogadorRespondeAposta ou pedirApostaJogador deve destravar o fluxo.
             return;
         }

        podeJogar = false; // Jogador não pode interagir enquanto a máquina joga

        let indiceEscolhido = 0;
        // --- Lógica da IA (Mantida do Código 1) ---
        if (maoMaquina.length > 0) {
             if (cartaJogadaCentroJogador) { // Máquina está respondendo
                let indiceGanhadora = -1, forcaGanhadoraMaisFraca = 1001;
                let indicePerdedoraMaisFraca = 0, forcaPerdedoraMaisFraca = -1;

                 // Acha a perdedora mais fraca (default)
                 if(maoMaquina.length > 0) {
                    forcaPerdedoraMaisFraca = calcularForca(maoMaquina[0]);
                    for(let i = 1; i < maoMaquina.length; i++) {
                         const forcaAtual = calcularForca(maoMaquina[i]);
                         if (forcaAtual < forcaPerdedoraMaisFraca) {
                              indicePerdedoraMaisFraca = i;
                              forcaPerdedoraMaisFraca = forcaAtual;
                          }
                     }
                     if (maoMaquina.length === 1) indicePerdedoraMaisFraca = 0; // Garante índice
                 }

                // Tenta achar a carta mais fraca que GANHA
                for(let i = 0; i < maoMaquina.length; i++) {
                   const forcaAtual = calcularForca(maoMaquina[i]);
                   if (compararCartasInterno(maoMaquina[i], cartaJogadaCentroJogador) === 'c1') { // Se ganha
                       if (indiceGanhadora === -1 || forcaAtual < forcaGanhadoraMaisFraca) {
                           indiceGanhadora = i;
                           forcaGanhadoraMaisFraca = forcaAtual;
                       }
                   }
                }
               indiceEscolhido = (indiceGanhadora !== -1) ? indiceGanhadora : indicePerdedoraMaisFraca;

            } else { // Máquina está iniciando a troca
                 // Joga a carta mais forte
                 let indiceMaisForte = 0, forcaMaisForte = -1;
                 for(let i = 0; i < maoMaquina.length; i++) {
                     let forcaAtual = calcularForca(maoMaquina[i]);
                     if(forcaAtual > forcaMaisForte) {
                         forcaMaisForte = forcaAtual;
                         indiceMaisForte = i;
                     }
                 }
                 indiceEscolhido = indiceMaisForte;
            }
        } else {
             console.warn("Máquina sem cartas para jogar.");
             // Passa a vez se não tem carta (não deveria ocorrer)
             jogadorDaVez = 'jogador';
             podeJogar = true;
             renderizarMaos(); // Atualiza visual jogador
             atualizarBotoesTruco();
             atualizarIndicadorTurno();
             if(cartaJogadaCentroJogador) { // Se só o jogador jogou, finaliza
                  setTimeout(finalizarRodada, 500);
             }
             return;
        }

        // Garante que o índice é válido
        if (indiceEscolhido < 0 || indiceEscolhido >= maoMaquina.length) indiceEscolhido = 0;

        cartaJogadaCentroMaquina = maoMaquina.splice(indiceEscolhido, 1)[0];
        renderizarMaoMaquinaReal(); // Atualiza a mão da máquina (com placeholders)

        // Mostra a carta jogada no centro
        if (elJogadaMaquina) {
            elJogadaMaquina.innerHTML = '';
            const cartaEl = criarElementoCarta(cartaJogadaCentroMaquina);
            elJogadaMaquina.appendChild(cartaEl);
            // Animação de entrada (opcional, do Visual 2)
            cartaEl.style.opacity = '0';
            cartaEl.style.transform = 'translateY(-15px) scale(0.9)';
            requestAnimationFrame(() => {
                 cartaEl.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
                 cartaEl.style.opacity = '1';
                 cartaEl.style.transform = 'translateY(0) scale(1)';
            });
        }
        console.log(`Máquina jogou: ${formatarValorDisplay(cartaJogadaCentroMaquina.valor)}${cartaJogadaCentroMaquina.naipe}`);

        jogadorDaVez = 'jogador'; // Passa a vez para o jogador

        // Decide o próximo passo
        if (!cartaJogadaCentroJogador) { // Se a máquina iniciou a troca
            quemIniciouRodada = 'maquina';
            if (jogoEmAndamento) { // Só permite se o jogo ainda está ativo
                podeJogar = true; // Permite ao jogador jogar
                renderizarMaos(); // Atualiza visual mão jogador (com highlight/onclick)
                atualizarBotoesTruco(); // Habilita botão de truco (se aplicável)
                atualizarIndicadorTurno(); // Move brilho para jogador
                 // Não chama iniciarTurno, aguarda ação do jogador
            }
        } else { // Ambas as cartas estão na mesa
            podeJogar = false; // Jogador não pode jogar enquanto compara
            atualizarIndicadorTurno(); // Remove brilho temporariamente
            setTimeout(finalizarRodada, 500); // Compara as cartas
        }
    }

    // --- Lógica de Decisão da Máquina (Aposta ou Joga) - Lógica 1 Mantida ---
    function maquinaDecideJogada() {
        if (!jogoEmAndamento || jogadorDaVez !== 'maquina' || estadoTruco === 'finalizado') {
             console.log("maquinaDecideJogada: Bloqueado - Jogo:", jogoEmAndamento, "Vez:", jogadorDaVez, "Estado:", estadoTruco);
             return;
        }
        atualizarIndicadorTurno(); // Garante que o brilho está na máquina

        // 1. Se há um pedido do JOGADOR pendente, a máquina PRECISA responder.
        if (estadoTruco.startsWith('pedido_') && estadoTruco.endsWith('_jogador')) {
             console.log("[IA Decisão] Aposta do jogador pendente. Respondendo...");
             setTimeout(maquinaRespondeAposta, 800 + Math.random() * 700); // Delay para resposta
             return; // Não faz mais nada até responder
        }

        // 2. Se NÃO HÁ pedido pendente, avalia se DEVE pedir/aumentar a aposta.
        const infoNivelAtualParaDecisao = NIVEIS_APOSTA[nivelApostaAtual];
        // Pode pedir se: há próximo nível E (estado normal OU jogador aceitou aposta da máquina)
        const podePedirAgora = infoNivelAtualParaDecisao.proximo &&
                               !estadoTruco.startsWith('pedido_') && // Segurança extra
                               (estadoTruco === 'normal' || (estadoTruco.startsWith('aceito_') && quemPediuUltimaAposta === 'jogador'));

        if (podePedirAgora && maquinaAvaliaPedirAposta()) { // Usa a função de avaliação da IA
            console.log("[IA Decisão] Máquina vai pedir/aumentar aposta.");
            const nivelCorretoParaPedir = infoNivelAtualParaDecisao.proximo;
            if (nivelCorretoParaPedir) {
                setTimeout(() => pedirApostaMaquina(nivelCorretoParaPedir), 600 + Math.random() * 600); // Delay para pedir
            } else {
                console.warn("IA tentou pedir aposta, mas não há próximo nível (fallback). Jogando carta.");
                maquinaJogaCarta(); // Joga carta como fallback
            }
        }
        else {
             // 3. Se não vai pedir/aumentar, JOGA UMA CARTA.
             console.log("[IA Decisão] Máquina vai jogar uma carta.");
             maquinaJogaCarta(); // Chama a função de jogar carta
        }
    }

    // --- Lógica de Aposta (Pedir, Avaliar, Responder) - Lógica 1 Mantida com Adaptações Visuais ---

    function pedirApostaJogador() {
        const infoNivelAtual = NIVEIS_APOSTA[nivelApostaAtual];
        const proximoNivelChave = infoNivelAtual.proximo;
        if (!proximoNivelChave) {
            mostrarMensagemTruco("Aposta já está no máximo!", 2000);
            return;
        }

        // Revalida se pode pedir AGORA
        const podePedir = jogoEmAndamento && podeJogar && jogadorDaVez === 'jogador' &&
                          !estadoTruco.startsWith('pedido_') &&
                          (estadoTruco === 'normal' || (estadoTruco.startsWith('aceito_') && quemPediuUltimaAposta === 'maquina'));

        if (!podePedir) {
            console.warn("Jogador não pode pedir aposta agora.", {jogo: jogoEmAndamento, podeJogar: podeJogar, vez: jogadorDaVez, estado: estadoTruco, ultimoPedido: quemPediuUltimaAposta});
            if (estadoTruco.startsWith('pedido_')) mostrarMensagemTruco("Aguarde a resposta ou responda primeiro!", 2500);
            else if (!podeJogar || jogadorDaVez !== 'jogador') mostrarMensagemTruco("Não é sua vez de pedir/jogar!", 2500);
            else mostrarMensagemTruco("Não pode aumentar a aposta agora.", 2500);
            return;
        }

        const infoProximoNivel = NIVEIS_APOSTA[proximoNivelChave];
        console.log(`Jogador pediu ${infoProximoNivel.nomeDisplay}!`);
        estadoTruco = `pedido_${proximoNivelChave.toLowerCase()}_jogador`;
        quemPediuUltimaAposta = 'jogador';
        podeJogar = false; // Não pode jogar carta enquanto espera resposta

        jogadorDaVez = 'maquina'; // <<< Passa a vez para a máquina RESPONDER

        renderizarMaos(); // Atualiza visual mão jogador (sem highlight/onclick)
        atualizarBotoesTruco(); // Desabilita botão principal do jogador, limpa respostas
        mostrarMensagemTruco(`Você pediu ${infoProximoNivel.nomeDisplay}! Aguardando máquina...`, 0); // Mensagem persistente
        atualizarIndicadorTurno(); // Brilho vai para a máquina

        // A máquina agora vai decidir como responder
        setTimeout(maquinaDecideJogada, 1500 + Math.random() * 1000); // Delay IA
    }

    function pedirApostaMaquina(nivelParaPedirChave) {
        // Chamado pela IA
        if (!nivelParaPedirChave || !NIVEIS_APOSTA[nivelParaPedirChave]) {
            console.error(`IA: Tentativa de pedir nível inválido: ${nivelParaPedirChave}`);
            if (jogadorDaVez === 'maquina') maquinaJogaCarta(); // Fallback
            return;
        }

        const infoNivelPedido = NIVEIS_APOSTA[nivelParaPedirChave];
        console.log(`Máquina pediu ${infoNivelPedido.nomeDisplay}!`);

        estadoTruco = `pedido_${nivelParaPedirChave.toLowerCase()}_maquina`;
        quemPediuUltimaAposta = 'maquina';
        podeJogar = false; // Jogador não pode jogar carta, tem que responder
        jogadorDaVez = 'jogador'; // <<< A vez é do jogador para RESPONDER

        mostrarMensagemTruco(`Máquina pediu ${infoNivelPedido.nomeDisplay}! Responda:`, 0); // Persistente

        // Cria botões de resposta (Visual 2)
        if (elRespostaTruco) {
            elRespostaTruco.innerHTML = ''; // Limpa
            elRespostaTruco.style.display = 'flex'; // Garante visibilidade do container
            // Aceitar
            elRespostaTruco.innerHTML += `<button id="botao-aceitar-truco" onclick="jogadorRespondeAposta('aceitar')">Aceitar (${infoNivelPedido.valor} pts)</button>`;
            // Recusar
            const pontosRecusa = infoNivelPedido.recusaPaga;
            elRespostaTruco.innerHTML += `<button id="botao-recusar-truco" onclick="jogadorRespondeAposta('recusar')">Recusar (-${pontosRecusa} pt${pontosRecusa > 1 ? 's' : ''})</button>`;
            // Aumentar (se possível)
            if (infoNivelPedido.proximo) {
                const proximoAumentoInfo = NIVEIS_APOSTA[infoNivelPedido.proximo];
                elRespostaTruco.innerHTML += `<button id="botao-aumentar-aposta" onclick="jogadorRespondeAposta('aumentar')">${proximoAumentoInfo.nomeDisplay}!</button>`;
            }
        }
        renderizarMaos(); // Atualiza visual mão jogador (não clicável)
        atualizarBotoesTruco(); // Desabilita botão principal jogador, mostra respostas
        atualizarIndicadorTurno(); // Brilho no jogador (para responder)
    }

    // IA avalia se deve pedir/aumentar (Lógica 1 Mantida)
    function maquinaAvaliaPedirAposta() {
         if(maoMaquina.length === 0) return false;
         const temManilha = maoMaquina.some(carta => calcularForca(carta) >= 997);
         const fortes = maoMaquina.filter(carta => calcularForca(carta) >= VALOR_MAP['A']).length;
         const nivelAtualChave = nivelApostaAtual;

         switch(nivelAtualChave) {
             case 'NORMAL': // Pedir TRUCO
                 return temManilha || fortes >= 2 || (fortes >= 1 && vitoriasRodadaMaquina > vitoriasRodadaJogador) ;
             case 'TRUCO': // Pedir SEIS
                 return temManilha && fortes >= 1;
             case 'SEIS': // Pedir NOVE
                  return temManilha && fortes >= 2;
             case 'NOVE': // Pedir DOZE
                 const temZap = maoMaquina.some(c => calcularForca(c) === 1000);
                 // Lógica um pouco mais conservadora para DOZE
                 return temZap && (maoMaquina.some(c => calcularForca(c) >= 997 && calcularForca(c) < 1000) || fortes >= 2); // Zap + Outra Manilha OU Zap + >=2 Fortes
             default: return false;
         }
    }

    // IA responde a um pedido do JOGADOR (Lógica 1 Mantida com Adaptações Visuais)
    function maquinaRespondeAposta() {
         if (!estadoTruco.startsWith('pedido_') || !estadoTruco.endsWith('_jogador')) {
             console.error("IA: Função maquinaRespondeAposta chamada em estado inválido:", estadoTruco);
             if(jogadorDaVez === 'maquina') maquinaJogaCarta(); // Tenta jogar se algo deu errado
             return;
         }

         const nivelPedidoChave = estadoTruco.split('_')[1].toUpperCase();
         const nivelPedidoInfo = NIVEIS_APOSTA[nivelPedidoChave];
         const pontosGanhosPelaRecusa = nivelPedidoInfo.recusaPaga;

         // Se máquina sem cartas, recusa
         if(maoMaquina.length === 0) {
             console.log("[IA Resp Aposta] Sem cartas, máquina recusa.");
             mostrarMensagemTruco(`Máquina Recusou (sem cartas)! Você ganhou ${pontosGanhosPelaRecusa} ponto${pontosGanhosPelaRecusa > 1 ? 's' : ''}.`, 4000);
             pontuacaoJogador += pontosGanhosPelaRecusa;
             mostrarPlacar();
             finalizarMaoAposRecusa();
             return;
         }

         // Avalia a mão (Lógica 1)
         const temManilha = maoMaquina.some(carta => calcularForca(carta) >= 997);
         const fortes = maoMaquina.filter(carta => calcularForca(carta) >= VALOR_MAP['A']).length;
         let decisao = 'recusar';

         // Lógica de decisão (Lógica 1)
         switch(nivelPedidoChave) {
             case 'TRUCO':
                 if (temManilha || fortes >= 1) decisao = 'aceitar';
                 // Avalia aumentar para SEIS
                 if (decisao === 'aceitar' && nivelPedidoInfo.proximo === 'SEIS' && maquinaAvaliaPedirAposta()) { decisao = 'aumentar'; }
                 break;
             case 'SEIS':
                 if (temManilha && fortes >= 1) decisao = 'aceitar';
                 // Avalia aumentar para NOVE
                 if (decisao === 'aceitar' && nivelPedidoInfo.proximo === 'NOVE' && maquinaAvaliaPedirAposta()) { decisao = 'aumentar'; }
                 break;
             case 'NOVE':
                  if (temManilha && fortes >= 2) decisao = 'aceitar';
                   // Avalia aumentar para DOZE
                  if (decisao === 'aceitar' && nivelPedidoInfo.proximo === 'DOZE' && maquinaAvaliaPedirAposta()) { decisao = 'aumentar'; }
                 break;
             case 'DOZE':
                  const temZap = maoMaquina.some(c => calcularForca(c) === 1000);
                  if (temManilha && temZap && fortes >=1 ) decisao = 'aceitar';
                 break;
         }

         console.log(`[IA Resp Aposta] Jogador pediu: ${nivelPedidoChave}. Mão(M:${temManilha}, F:${fortes}). Decisão: ${decisao}`);

         // Executa a decisão
         if (decisao === 'aceitar') {
             console.log(`Máquina ACEITOU o ${nivelPedidoInfo.nomeDisplay}!`);
             estadoTruco = `aceito_${nivelPedidoChave.toLowerCase()}`;
             nivelApostaAtual = nivelPedidoChave;
             pontosDaMaoAtual = nivelPedidoInfo.valor;
             quemPediuUltimaAposta = 'jogador'; // Jogador pediu, máquina aceitou
             atualizarValorMaoDisplay();
             mostrarMensagemTruco(`Máquina Aceitou! Mão vale ${pontosDaMaoAtual}. Sua vez.`, 3500);

             // A vez volta para quem pediu (jogador)
             jogadorDaVez = 'jogador';
             podeJogar = true; // Jogador pode jogar CARTA agora
             renderizarMaos(); // Habilita cartas do jogador
             atualizarBotoesTruco(); // Habilita botão de aumentar do jogador (se aplicável)
             atualizarIndicadorTurno(); // Brilho no jogador

         } else if (decisao === 'aumentar') {
              const proximoNivelAumento = nivelPedidoInfo.proximo;
              if (!proximoNivelAumento) { // Segurança
                    console.error("IA tentou aumentar além do DOZE! Aceitando como fallback.");
                    // Executa aceite como fallback
                     console.log(`Máquina ACEITOU o ${nivelPedidoInfo.nomeDisplay}! (Fallback)`);
                     estadoTruco = `aceito_${nivelPedidoChave.toLowerCase()}`;
                     nivelApostaAtual = nivelPedidoChave;
                     pontosDaMaoAtual = nivelPedidoInfo.valor;
                     quemPediuUltimaAposta = 'jogador';
                     atualizarValorMaoDisplay();
                     mostrarMensagemTruco(`Máquina Aceitou! Mão vale ${pontosDaMaoAtual}. Sua vez.`, 3500);
                     jogadorDaVez = 'jogador';
                     podeJogar = true;
                     renderizarMaos();
                     atualizarBotoesTruco();
                     atualizarIndicadorTurno();
                    return;
              }
              console.log(`Máquina decidiu AUMENTAR para ${NIVEIS_APOSTA[proximoNivelAumento].nomeDisplay}!`);
              // A máquina agora PEDE o próximo nível (vai mostrar botões pro jogador)
              pedirApostaMaquina(proximoNivelAumento);

         } else { // Recusar
             console.log(`Máquina RECUSOU o ${nivelPedidoInfo.nomeDisplay}!`);
             mostrarMensagemTruco(`Máquina Recusou! Você ganhou ${pontosGanhosPelaRecusa} ponto${pontosGanhosPelaRecusa > 1 ? 's' : ''}.`, 4000);
             pontuacaoJogador += pontosGanhosPelaRecusa;
             mostrarPlacar();
             finalizarMaoAposRecusa(); // Encerra a mão
         }
    }

    // Jogador responde a um pedido da MÁQUINA (Lógica 1 Mantida com Adaptações Visuais)
    function jogadorRespondeAposta(resposta) {
         if (!estadoTruco.startsWith('pedido_') || !estadoTruco.endsWith('_maquina')) {
             console.error("Jogador tentou responder aposta em estado inválido:", estadoTruco);
             mostrarMensagemTruco("Não há aposta da máquina para responder.", 2000);
             return;
         }

         const nivelPedidoChave = estadoTruco.split('_')[1].toUpperCase();
         const nivelPedidoInfo = NIVEIS_APOSTA[nivelPedidoChave];
         const pontosGanhosPelaRecusa = nivelPedidoInfo.recusaPaga;

         if (elRespostaTruco) elRespostaTruco.innerHTML = ''; // Limpa botões de resposta
         // CSS :empty cuida de esconder a área

         if (resposta === 'aceitar') {
             console.log(`Jogador ACEITOU o ${nivelPedidoInfo.nomeDisplay}!`);
             estadoTruco = `aceito_${nivelPedidoChave.toLowerCase()}`;
             nivelApostaAtual = nivelPedidoChave;
             pontosDaMaoAtual = nivelPedidoInfo.valor;
             quemPediuUltimaAposta = 'maquina'; // Máquina pediu, jogador aceitou
             atualizarValorMaoDisplay();
             mostrarMensagemTruco(`Você Aceitou! Mão vale ${pontosDaMaoAtual}. Vez da máquina.`, 3500);

             // A vez continua/volta para quem pediu (máquina)
             jogadorDaVez = 'maquina';
             podeJogar = false; // Jogador não pode jogar carta
             renderizarMaos(); // Desabilita cartas jogador
             atualizarBotoesTruco(); // Atualiza botões
             atualizarIndicadorTurno(); // Brilho na máquina
             // Máquina agora decide se joga ou aumenta (se possível)
             setTimeout(maquinaDecideJogada, 1000);

         } else if (resposta === 'aumentar') {
             const proximoNivelChave = nivelPedidoInfo.proximo;
             if (!proximoNivelChave) {
                 console.error("Erro: Jogador tentou aumentar além do Doze!");
                 pedirApostaMaquina(nivelPedidoChave); // Reapresenta botões do Doze
                 return;
             }
             console.log(`Jogador decidiu AUMENTAR para ${NIVEIS_APOSTA[proximoNivelChave].nomeDisplay}!`);
             const infoProximoNivel = NIVEIS_APOSTA[proximoNivelChave];

             // Agora o JOGADOR está pedindo o próximo nível
             estadoTruco = `pedido_${proximoNivelChave.toLowerCase()}_jogador`;
             quemPediuUltimaAposta = 'jogador';
             podeJogar = false;
             jogadorDaVez = 'maquina'; // <<< Passa a vez para a máquina RESPONDER

             mostrarMensagemTruco(`Você pediu ${infoProximoNivel.nomeDisplay}! Aguardando máquina...`, 0); // Persistente
             renderizarMaos(); // Desabilita cartas jogador
             atualizarBotoesTruco(); // Desabilita botão principal jogador
             atualizarIndicadorTurno(); // Brilho na máquina (para responder)
             // Máquina precisa responder a este novo pedido
             setTimeout(maquinaDecideJogada, 1500 + Math.random() * 1000);

         } else { // Recusar
             console.log(`Jogador RECUSOU o ${nivelPedidoInfo.nomeDisplay}!`);
             mostrarMensagemTruco(`Você Recusou! Máquina ganhou ${pontosGanhosPelaRecusa} ponto${pontosGanhosPelaRecusa > 1 ? 's' : ''}.`, 4000);
             pontuacaoMaquina += pontosGanhosPelaRecusa;
             mostrarPlacar();
             finalizarMaoAposRecusa(); // Encerra a mão
         }
    }

    // --- Finalização da Mão e Jogo ---

    // <<< MODIFICADO: finalizarMaoAposRecusa com Visual 2 >>>
    function finalizarMaoAposRecusa() {
         console.log("Finalizando mão após recusa de aposta.");
         // Pontuação e mensagem já foram dadas
         nivelApostaAtual = 'NORMAL'; // Reseta para próxima mão
         estadoTruco = 'normal';
         podeJogar = false;
         renderizarMaoMaquinaReal(true); // Revela cartas da máquina com estilo Visual 2

         atualizarIndicadorTurno(); // Remove brilho de turno
         atualizarBotoesTruco(); // Limpa botões de resposta, pode mostrar "Jogar Novamente"

         // Verifica fim de JOGO
         if (pontuacaoJogador >= PONTOS_VITORIA || pontuacaoMaquina >= PONTOS_VITORIA) {
             jogoEmAndamento = false;
             estadoTruco = 'finalizado'; // Marca jogo como finalizado
             // Garante que a mensagem final correta seja exibida
             let msgFinal = `FIM DE JOGO! ${pontuacaoJogador >= PONTOS_VITORIA ? 'VOCÊ VENCEU' : 'A MÁQUINA VENCEU'} (por recusa)! Placar: ${pontuacaoJogador} x ${pontuacaoMaquina}`;
             // Pequeno delay para garantir que a mensagem de recusa seja vista
             setTimeout(() => {
                 mostrarMensagemTruco(msgFinal, 0); // Mostra mensagem final persistente
                 atualizarBotoesTruco(); // Mostra botão "Jogar Novamente"
             }, 100); // Delay curto
             console.log("Fim de jogo detectado após recusa.");
             vencedorDaMaoAnterior = (pontuacaoJogador >= PONTOS_VITORIA) ? 'jogador' : 'maquina'; // Define quem começaria próximo jogo
         } else {
             // Prepara próxima mão
             console.log("Preparando próxima mão após recusa...");
             // Quem ganhou os pontos da recusa começa a próxima mão
             vencedorDaMaoAnterior = quemPediuUltimaAposta === 'jogador' ? 'maquina' : 'jogador'; // Inverte quem pediu

             setTimeout(() => {
                  if (jogoEmAndamento && estadoTruco !== 'finalizado') {
                     iniciarPartida();
                 }
             }, 4500); // Tempo maior para ler mensagem e ver cartas
         }
    }

    // <<< ADICIONADO do Visual 2: Função para animar bolinha >>>
    function atualizarBolinhaRodada(numeroRodada, classeResultado) {
        const bolinha = document.getElementById(`bolinha-rodada${numeroRodada}`);
        if (!bolinha) {
            console.error("Elemento bolinha não encontrado para rodada:", numeroRodada);
            return;
        }

        // Remove classes antigas de resultado, mas mantém 'bolinha'
        bolinha.className = 'bolinha';

        // Força reflow para garantir que a transição CSS seja aplicada corretamente
        // ao adicionar a classe novamente, mesmo que seja a mesma.
        void bolinha.offsetWidth;

        // Adiciona classe para iniciar animação de preenchimento ('preenchendo')
        // e a classe do resultado ('vencedor-jogador', 'vencedor-maquina', 'empate')
        if (classeResultado) { // Só adiciona se houver um resultado
             bolinha.classList.add('preenchendo', classeResultado);
        }

        // Opcional: Remover 'preenchendo' depois da animação para permitir re-animação futura.
        // Pode não ser necessário se a classe de resultado for removida no início da próxima mão.
        // setTimeout(() => {
        //     bolinha.classList.remove('preenchendo');
        // }, 500); // Tempo > duração da transição CSS
    }

    // <<< MODIFICADO: finalizarRodada com Visual 2 (chama atualizarBolinhaRodada) >>>
    function finalizarRodada() {
        // Só finaliza se ambas as cartas foram jogadas e não há aposta pendente
        if (!jogoEmAndamento || estadoTruco === 'finalizado' || estadoTruco.startsWith('pedido_') || !cartaJogadaCentroJogador || !cartaJogadaCentroMaquina) {
            console.log("Tentativa de finalizar rodada inválida.", {estado:estadoTruco, jogo:jogoEmAndamento, cJ:!!cartaJogadaCentroJogador, cM:!!cartaJogadaCentroMaquina});
            return;
        }

        podeJogar = false; // Ninguém joga enquanto processa

        const cJogador = cartaJogadaCentroJogador;
        const cMaquina = cartaJogadaCentroMaquina;
        const resultado = compararCartasInterno(cJogador, cMaquina);
        let proximoJogadorIniciaRodada = quemIniciouRodada; // Quem começa a próxima por padrão
        let classeBolinha = ''; // Classe CSS para a bolinha

         console.log(`Resultado Rodada ${rodadaAtual}: Jogador(${formatarValorDisplay(cJogador.valor)}${cJogador.naipe}) vs Máquina(${formatarValorDisplay(cMaquina.valor)}${cMaquina.naipe}) -> ${resultado}`);

        if (resultado === 'c1') { // Jogador ganhou
            vitoriasRodadaJogador++;
            classeBolinha = 'vencedor-jogador';
            proximoJogadorIniciaRodada = 'jogador';
        } else if (resultado === 'c2') { // Máquina ganhou
            vitoriasRodadaMaquina++;
             classeBolinha = 'vencedor-maquina';
            proximoJogadorIniciaRodada = 'maquina';
        } else { // Empate
            empatesRodada++;
            classeBolinha = 'empate';
            // Quem começou esta rodada, começa a próxima se empatar
            proximoJogadorIniciaRodada = quemIniciouRodada;
            console.log(`Rodada ${rodadaAtual} empatou. Próximo a iniciar: ${proximoJogadorIniciaRodada}`);
        }

        // Atualiza a bolinha visualmente (com animação)
        atualizarBolinhaRodada(rodadaAtual, classeBolinha);

        // Define quem joga na PRÓXIMA rodada
        jogadorDaVez = proximoJogadorIniciaRodada;
        quemIniciouRodada = proximoJogadorIniciaRodada; // Atualiza quem vai iniciar a próxima troca
        rodadaAtual++; // Avança o contador de rodada

        // Delay para limpar a mesa e verificar fim da mão/jogo
        setTimeout(() => {
            // Limpa as cartas do centro
            if(elJogadaJogador) elJogadaJogador.innerHTML = '';
            if(elJogadaMaquina) elJogadaMaquina.innerHTML = '';
            cartaJogadaCentroJogador = null;
            cartaJogadaCentroMaquina = null;

            // Verifica se a MÃO acabou (e talvez o JOGO)
            if(jogoEmAndamento && estadoTruco !== 'finalizado') {
                 if (!verificarFimPartida()) { // Se a mão NÃO acabou
                      iniciarTurno(); // Prepara o início da PRÓXIMA rodada
                 }
                 // Se verificarFimPartida() retornou true, ela já cuidou do fluxo (nova mão ou fim de jogo)
             } else {
                  console.log("FinalizarRodada: Jogo/Mão já encerrado ou pausado.");
                  if(estadoTruco === 'finalizado') atualizarBotoesTruco(); // Garante botões finais
             }
        }, 1800); // Tempo para ver resultado e animação da bolinha
    }

    // Verifica se a MÃO terminou (Lógica 1 Mantida com Adaptações Visuais)
    function verificarFimPartida() {
        if (!jogoEmAndamento || estadoTruco.startsWith('pedido_') || estadoTruco === 'finalizado') return false;

        let fimDeMao = false;
        let vencedorMao = null;
        let motivo = "";
        let pontosGanhosNaMao = pontosDaMaoAtual;

        // --- Lógica de Fim de Mão (Lógica 1) ---
        // 1. Alguém fez 2 vitórias?
         if (vitoriasRodadaJogador >= 2) { fimDeMao = true; vencedorMao = 'jogador'; motivo = "Jogador fez 2 vitórias."; }
         else if (vitoriasRodadaMaquina >= 2) { fimDeMao = true; vencedorMao = 'maquina'; motivo = "Máquina fez 2 vitórias."; }
         // 2. Regras de empate (após 2ª ou 3ª rodada)
         else if (rodadaAtual > 2) { // Só checa após a 2ª rodada ter sido processada
             const b1 = document.getElementById('bolinha-rodada1')?.classList;
             const b2 = document.getElementById('bolinha-rodada2')?.classList;
             const b3 = document.getElementById('bolinha-rodada3')?.classList; // Pode ainda não ter classes de resultado

             const b1Empate = b1?.contains('empate');
             const b2Empate = b2?.contains('empate');

             if (b1Empate && !b2Empate) { // Empatou 1ª, decidiu na 2ª
                 if (b2?.contains('vencedor-jogador')) { fimDeMao = true; vencedorMao = 'jogador'; motivo = "Empatou 1a, Jogador ganhou 2a."; }
                 else if (b2?.contains('vencedor-maquina')) { fimDeMao = true; vencedorMao = 'maquina'; motivo = "Empatou 1a, Máquina ganhou 2a."; }
             } else if (!b1Empate && b2Empate) { // Ganhou 1ª, Empatou 2ª -> Quem ganhou a 1ª leva
                 // Esta condição já define o fim da mão na 2ª rodada
                 if (b1?.contains('vencedor-jogador')) { fimDeMao = true; vencedorMao = 'jogador'; motivo = "Jogador ganhou 1a, Empatou 2a."; }
                 else if (b1?.contains('vencedor-maquina')) { fimDeMao = true; vencedorMao = 'maquina'; motivo = "Máquina ganhou 1a, Empatou 2a."; }
             } else if (b1Empate && b2Empate && rodadaAtual > 3) { // Empatou 1ª e 2ª, decide na 3ª (rodadaAtual > 3 confirma que 3a terminou)
                 const b3Empate = b3?.contains('empate');
                 if (b3?.contains('vencedor-jogador')) { fimDeMao = true; vencedorMao = 'jogador'; motivo = "Empatou 1a e 2a, Jogador ganhou 3a."; }
                 else if (b3?.contains('vencedor-maquina')) { fimDeMao = true; vencedorMao = 'maquina'; motivo = "Empatou 1a e 2a, Máquina ganhou 3a."; }
                 else if (b3Empate) { // Empate triplo
                    fimDeMao = true; vencedorMao = null; motivo = "Empate triplo (cangou)."; pontosGanhosNaMao = 0;
                 }
            }
         }
         // 3. Fim da 3ª rodada sem resolução por 2 vitórias ou empates específicos
         if (!fimDeMao && rodadaAtual > 3) {
              fimDeMao = true; // Acabaram as rodadas
              motivo = "3 rodadas completas. ";
              if (vitoriasRodadaJogador > vitoriasRodadaMaquina) { vencedorMao = 'jogador'; motivo += "Jogador com mais vitórias."; }
              else if (vitoriasRodadaMaquina > vitoriasRodadaJogador) { vencedorMao = 'maquina'; motivo += "Máquina com mais vitórias."; }
              else { // Empate em vitórias (1x1 e 1 empate)
                   const b1 = document.getElementById('bolinha-rodada1')?.classList;
                   if (b1?.contains('vencedor-jogador')) { vencedorMao = 'jogador'; motivo += `Desempate pela 1a rodada (jogador).`; }
                   else if (b1?.contains('vencedor-maquina')) { vencedorMao = 'maquina'; motivo += `Desempate pela 1a rodada (máquina).`; }
                   else { // Empatou a primeira também? Leva ao caso de Empate 1a/2a/3a
                       console.warn("Desempate inesperado após 3 rodadas com vitórias iguais.", {vJ:vitoriasRodadaJogador, vM:vitoriasRodadaMaquina, E:empatesRodada});
                       vencedorMao = null; motivo += "Empate complexo."; pontosGanhosNaMao = 0;
                   }
              }
         }

        // --- Processamento do Fim da Mão ---
        if (fimDeMao) {
            console.log(`---------------- Fim da Mão (${motivo}) ----------------`);
            podeJogar = false; // Ninguém joga mais
            estadoTruco = 'normal'; // Reseta estado de aposta
            renderizarMaoMaquinaReal(true); // Revela cartas da máquina
            atualizarIndicadorTurno(); // Remove brilho de turno

            vencedorDaMaoAnterior = vencedorMao; // Guarda quem ganhou para iniciar próxima

            // Atribui pontos e mostra mensagem
            if (vencedorMao === 'jogador') {
                pontuacaoJogador += pontosGanhosNaMao;
                mostrarMensagemTruco(`Você ganhou a mão! (+${pontosGanhosNaMao} pt${pontosGanhosNaMao > 1 ? 's': ''})`, 4000);
            } else if (vencedorMao === 'maquina') {
                pontuacaoMaquina += pontosGanhosNaMao;
                 mostrarMensagemTruco(`Máquina ganhou a mão! (+${pontosGanhosNaMao} pt${pontosGanhosNaMao > 1 ? 's': ''})`, 4000);
            } else { // Empate (cangou)
                vencedorDaMaoAnterior = 'jogador'; // Se empatou, jogador humano começa a próxima
                mostrarMensagemTruco("Mão empatou! Ninguém pontua.", 4000);
            }
            mostrarPlacar(); // Atualiza placar geral

            // --- Verifica Fim de JOGO ---
             if (pontuacaoJogador >= PONTOS_VITORIA || pontuacaoMaquina >= PONTOS_VITORIA) {
                 jogoEmAndamento = false;
                 estadoTruco = 'finalizado';
                 // Mostra mensagem final após um breve delay
                 setTimeout(() => {
                      let msgFinal = `FIM DE JOGO! ${pontuacaoJogador >= PONTOS_VITORIA ? 'VOCÊ VENCEU!' : 'A MÁQUINA VENCEU!'} Placar: ${pontuacaoJogador} x ${pontuacaoMaquina}`;
                      console.log(msgFinal);
                      mostrarMensagemTruco(msgFinal, 0); // Persistente
                      atualizarBotoesTruco(); // Mostra botão Jogar Novamente
                 }, 500); // Delay
             } else {
                 // --- Prepara a Próxima Mão ---
                 console.log(`Preparando próxima mão... Vencedor anterior: ${vencedorDaMaoAnterior}`);
                 setTimeout(() => {
                     if (jogoEmAndamento && estadoTruco !== 'finalizado') { // Re-checa estado
                         iniciarPartida();
                     }
                 }, 4500); // Tempo maior para ler msg e ver cartas
             }
             return true; // Mão terminou
        }

        return false; // Mão continua
    }

    // --- Controle de Turno e Placar ---

            // <<< MODIFICADO: iniciarTurno com Visual 2 (chama renderizarMaos e atualizarIndicadorTurno) >>>
    function iniciarTurno() {
        // Chamado no início de cada rodada ou quando a vez troca após aposta
       
        // CORREÇÃO AQUI: 'jogoEmAnadamento' alterado para 'jogoEmAndamento'
        if (!jogoEmAndamento || estadoTruco === 'finalizado') {
            console.log("Início de turno bloqueado: jogo finalizado.");
            atualizarIndicadorTurno(); // Garante que não há brilho
            atualizarBotoesTruco();
            return;
        }

        // CORREÇÃO: Limpa as cartas do centro da mesa no início de cada turno/rodada.
        if(elJogadaJogador) elJogadaJogador.innerHTML = '';
        if(elJogadaMaquina) elJogadaMaquina.innerHTML = '';
        cartaJogadaCentroJogador = null;
        cartaJogadaCentroMaquina = null;

        // Se está esperando resposta de aposta, não inicia turno de jogar carta
        if (estadoTruco.startsWith('pedido_')) {
            console.log("Início de turno bloqueado: aposta pendente -", estadoTruco);
            podeJogar = false; // Garante que jogador não pode jogar carta
            renderizarMaos(); // Atualiza visual sem jogabilidade
            atualizarBotoesTruco(); // Mostra/habilita botões de resposta se for vez do jogador
            atualizarIndicadorTurno(); // Indica quem deve responder/agir
            return;
        }

        console.log(`--- Rodada ${rodadaAtual}, Vez de ${jogadorDaVez}, Mão valendo ${pontosDaMaoAtual} ---`);

        if (jogadorDaVez === 'maquina') {
            podeJogar = false; // Jogador não pode interagir
            renderizarMaos(); // Atualiza visual jogador (não clicável)
            atualizarBotoesTruco(); // Desabilita botão truco jogador
            atualizarIndicadorTurno(); // Brilho na máquina
            // Máquina decide o que fazer (jogar ou apostar)
            setTimeout(maquinaDecideJogada, 1100 + Math.random() * 600);
        } else { // Vez do jogador
            podeJogar = true; // Jogador pode interagir
            renderizarMaos(); // Atualiza visual jogador (clicável/highlight)
            atualizarBotoesTruco(); // Habilita botão truco jogador (se aplicável)
            atualizarIndicadorTurno(); // Brilho no jogador
             console.log("Aguardando ação do jogador...");
        }
    }
    function mostrarPlacar() {
        if(elPlacarFinal){
             // O CSS já posiciona, só atualiza o texto
             elPlacarFinal.innerText = `Você ${pontuacaoJogador} x ${pontuacaoMaquina} Máquina`;
        } else { console.error("Elemento 'placar-final' não encontrado!") }
    }

        // --- Função para iniciar nova MÃO (Lógica 1 com Adaptações Visuais) ---
    function iniciarPartida() {
      if (!jogoEmAndamento && estadoTruco === 'finalizado') {
            console.log("Jogo finalizado. Esperando 'Jogar Novamente'.");
            return;
      }

      console.log("================ Início da Mão ================");
      jogoEmAndamento = true;
      estadoTruco = 'normal';
      if(elFimJogoControles) elFimJogoControles.style.display = 'none';
      if(elBotaoTruco) elBotaoTruco.style.display = 'flex';

      criarBaralho();
      embaralhar();
      // sortearManilha() foi REMOVIDO daqui. Será chamado por verificarMaoDeOnze() ou depois dela.
      distribuirCartas(); // Já chama renderizarMaos

      rodadaAtual = 1;
      vitoriasRodadaJogador = 0; vitoriasRodadaMaquina = 0; empatesRodada = 0;
      cartaJogadaCentroJogador = null; cartaJogadaCentroMaquina = null;

       // Lógica 1 para definir quem começa
        if (vencedorDaMaoAnterior === 'maquina') {
            console.log("Máquina começa esta mão.");
            jogadorDaVez = 'maquina';
        } else { // Jogador ganhou, empatou, ou é a primeira mão
            console.log("Jogador começa esta mão.");
            jogadorDaVez = 'jogador';
        }
       quemIniciouRodada = jogadorDaVez;

      nivelApostaAtual = 'NORMAL';
      pontosDaMaoAtual = NIVEIS_APOSTA.NORMAL.valor;
      quemPediuUltimaAposta = null;
      atualizarValorMaoDisplay();
      mostrarMensagemTruco('', 0); // Limpa mensagem
      if(elRespostaTruco) elRespostaTruco.innerHTML = ''; // Limpa respostas

      // Limpa bolinhas de rodada (remove classes de resultado)
      for (let i = 1; i <= 3; i++) {
          const bolinha = document.getElementById(`bolinha-rodada${i}`);
          if(bolinha) bolinha.className = 'bolinha'; // Reseta visual
      }
     
        // Limpa cartas do centro
    if(elJogadaJogador) elJogadaJogador.innerHTML = '';
    if(elJogadaMaquina) elJogadaMaquina.innerHTML = '';
    cartaJogadaCentroJogador = null;
    cartaJogadaCentroMaquina = null;
     
      // Checa e trata o caso de Mão de Onze/Ferro
      if (verificarMaoDeOnze()) {
        // Se retornar true, o fluxo da Mão de Onze prossegue.
        return;
      }
     
      // Se NÃO FOR Mão de Onze/Ferro, sorteia a vira e continua normalmente
      sortearManilha();
      // Já limpou área de cartas jogadas (ou vai limpar ao jogar)

      mostrarPlacar();
      podeJogar = false;
      iniciarTurno(); // Começa o primeiro turno da mão
    }

    // --- Função Jogar Novamente (Lógica 1 com Adaptações Visuais) ---
    function jogarNovamente() {
    console.log("==================== NOVO JOGO ====================");
    pontuacaoJogador = 0;
    pontuacaoMaquina = 0;
    estadoTruco = 'normal';
    jogoEmAndamento = true;
    vencedorDaMaoAnterior = 'jogador';
    iniciarPartida();
}

    // --- Função Revelar Cartas no Fim (usa renderizarMaoMaquinaReal) ---
    function revelarCartasMaquinaFimJogo() {
        // A lógica agora está dentro de renderizarMaoMaquinaReal(true)
        renderizarMaoMaquinaReal(true);
     }

    // --- Início do Jogo e Configuração do Menu (Lógica 1 com Adaptações Visuais) ---
    document.addEventListener('DOMContentLoaded', () => {
         let agora = new Date();
         try { agora = new Date(agora.toLocaleString('en-US', { timeZone: 'America/Sao_Paulo' })); }
         catch (e) { console.warn("Não foi possível obter hora de São Paulo.");}
         console.log("Truco Paulista (Lógica 1 + Visual 2) Carregado - Mogi Guaçu, SP: " + agora.toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' }));

         // Cache dos elementos (mesmos IDs do Código 1)
         menuInicio = document.getElementById('menu-inicio');
         regrasJogo = document.getElementById('regras-jogo');
         botaoJogarMenu = document.getElementById('botao-jogar-menu');
         botaoRegrasMenu = document.getElementById('botao-regras-menu');
         botaoVoltarMenu = document.getElementById('botao-voltar-menu');
         mesaJogo = document.getElementById('mesa');
         elMaoJogador=document.getElementById('mao-jogador');
         elMaoMaquina=document.getElementById('mao-maquina');
         elJogadaJogador=document.getElementById('jogada-jogador');
         elJogadaMaquina=document.getElementById('jogada-maquina');
         elCartaVirada=document.getElementById('carta-virada-display');
         elManilhaInfo=document.getElementById('manilha-info');
         elPlacarFinal=document.getElementById('placar-final');
         elValorMaoAtual=document.getElementById('valor-mao-atual');
         elBotaoTruco=document.getElementById('botao-truco');
         elMensagemTruco=document.getElementById('mensagem-truco');
         elRespostaTruco=document.getElementById('resposta-truco');
         elFimJogoControles=document.getElementById('fim-jogo-controles');
        
         elMaoOnzeOverlay = document.getElementById('mao-onze-overlay');
    elBotaoOnzeJogar = document.getElementById('botao-onze-jogar');
    elBotaoOnzeCorrer = document.getElementById('botao-onze-correr');

    elBotaoOnzeJogar.addEventListener('click', () => {
        elMaoOnzeOverlay.style.display = 'none';
        console.log("Jogador decidiu JOGAR a Mão de Onze.");
        mostrarMensagemTruco("Você aceitou! A mão vale 3 pontos.", 3000);
        // Reinicia a mão com as cartas já distribuídas
        estadoTruco = 'normal'; // Reseta o estado para a mão poder ser jogada
        sortearManilha();
        renderizarMaos();
        iniciarTurno();
    });

    elBotaoOnzeCorrer.addEventListener('click', () => {
        elMaoOnzeOverlay.style.display = 'none';
        console.log("Jogador decidiu CORRER a Mão de Onze.");
        mostrarMensagemTruco("Você correu! A Máquina ganhou 1 ponto.", 4000);
        pontuacaoMaquina += 1;
        mostrarPlacar();
        estadoTruco = 'normal'; // Reseta o estado
        finalizarMaoAposRecusa(); // Reutilizamos a função de recusa
    });

         // Validação básica dos elementos
         const elementosEssenciais = [ /* ... lista de elementos ... */ ]; // (Omitido para brevidade)
         if (elementosEssenciais.some(el => !el)) {
             console.error("ERRO GRAVE: Um ou mais elementos essenciais da UI não foram encontrados! Verifique os IDs no HTML.");
             alert("Erro ao carregar a interface do jogo. Verifique IDs e o console (F12).");
             return;
         } else {
              console.log("Elementos da UI encontrados.");
         }

         // Lógica dos botões do Menu (Lógica 1)
         botaoJogarMenu.addEventListener('click', () => {
             menuInicio.style.display = 'none';
             regrasJogo.style.display = 'none';
             mesaJogo.style.display = 'flex'; // Mostra a mesa (com display:flex do Visual 2)
             // Chama jogarNovamente para começar um jogo do zero
             jogarNovamente();
         });

         botaoRegrasMenu.addEventListener('click', () => {
             menuInicio.style.display = 'none';
             regrasJogo.style.display = 'flex';
         });

         botaoVoltarMenu.addEventListener('click', () => {
             regrasJogo.style.display = 'none';
             menuInicio.style.display = 'flex';
         });

         // --- Configuração Inicial Visual ---
         console.log("Interface carregada. Menu inicial exibido.");
         mostrarPlacar(); // Mostra placar 0 a 0
         renderizarMaoMaquinaReal(); // Mostra versos das cartas da máquina
         atualizarBotoesTruco(); // Garante estado inicial (Truco desabilitado, sem respostas)
         atualizarIndicadorTurno(); // Garante que nenhum turno está ativo inicialmente
         if(elMensagemTruco) elMensagemTruco.textContent = ''; // Limpa e esconde msg inicial
    });
   
   // ... (dentro da sua tag <script>)
function verificarMaoDeOnze() {
    // Garante que a distribuição foi feita e o placar está em 11
    if (pontuacaoJogador === 11 && pontuacaoMaquina === 11) {
        // Mão de Ferro
        console.log("Mão de Ferro! Ambos com 11 pontos.");
        estadoTruco = 'mao_de_ferro';
        pontosDaMaoAtual = 3;
        mostrarMensagemTruco("MÃO DE FERRO! Joguem suas cartas no escuro.", 0);
        sortearManilha(); // Sorteia a Vira
        // Cartas já foram distribuídas, renderizarMaos irá mostrá-las viradas (graças à renderizarMaos)
        renderizarMaos(); // Renderiza para atualizar visual do jogador (cartas viradas)
        iniciarTurno();
        return true;

    } else if (pontuacaoJogador === 11) {
        // Mão de Onze do jogador
        console.log("Mão de Onze do Jogador. Aguardando decisão...");
        estadoTruco = 'mao_de_onze_jogador';
        pontosDaMaoAtual = 3;
        atualizarValorMaoDisplay();
       
        sortearManilha(); // Sorteia a Vira AQUI (ANTES do modal)
        // Cartas já foram distribuídas
        renderizarMaos(); // Renderiza com as cartas do jogador visíveis E a vira no centro
       
        elMaoOnzeOverlay.style.display = 'flex';
        return true;

    } else if (pontuacaoMaquina === 11) {
        // Mão de Onze da máquina
        console.log("Mão de Onze da Máquina.");
        estadoTruco = 'mao_de_onze_maquina';
        pontosDaMaoAtual = 3;
        atualizarValorMaoDisplay();
        sortearManilha(); // Sorteia a Vira AQUI (ANTES da decisão da IA)
        // Cartas já foram distribuídas
        renderizarMaos(); // Renderiza com a vira no centro antes de o jogo começar
        return maquinaDecideMaoOnze();
    }

    return false;
}

// ... dentro da sua tag <script>
function maquinaDecideMaoOnze() {
    // A máquina decide com base na força de sua mão
    const forcas = maoMaquina.map(c => calcularForca(c));
    const temManilha = forcas.some(f => f >= 997);
    const fortes = forcas.filter(f => f >= VALOR_MAP['A']).length;

    // Lógica simples:
    // Se tiver uma manilha, uma carta forte, ou duas cartas razoáveis, ela joga.
    const deveJogar = temManilha || fortes >= 1 || (forcas.filter(f => f >= VALOR_MAP['Q']).length >= 2);

    if (deveJogar) {
        console.log("Máquina decidiu JOGAR a Mão de Onze.");
        mostrarMensagemTruco("Máquina decidiu jogar a Mão de Onze!", 3000);
        // Reseta o estado para normal para a mão poder ser jogada
        estadoTruco = 'normal';
        // Reinicia a mão com as cartas já distribuídas
        sortearManilha();
        renderizarMaos();
        iniciarTurno();
    } else {
        console.log("Máquina decidiu CORRER a Mão de Onze.");
        mostrarMensagemTruco("Máquina correu a Mão de Onze! Você ganhou 1 ponto.", 4000);
        pontuacaoJogador += 1;
        mostrarPlacar();
        estadoTruco = 'normal';
        finalizarMaoAposRecusa(); // Reutilizamos a função de recusa
    }
    return true; // Retorna true para a função que a chamou
}

</script>
</body>
</html>
